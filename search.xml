<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2-1/2.高阶函数]]></title>
    <url>%2F2018%2F06%2F17%2F2-1%3A2.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1开篇1.1.1 编辑器 vscode webstorm code runner (可以片段运行代码)1.1.2 es6 1.1.1.1 异步的发展流程1.1.1.1 异步和同步的区别 异步(setTimeout ajax 事件)和同步的区别:同步表示连续执行，异步表示非连续执行1.1.1.2 回调函数的两种表现形式 回调函数 函数(封装，私有化),即以下两种方式:(1)高阶函数,一个函数执行后返回一个函数(2)函数可以当作参数传递给另一个函数 2.1柯里化2.1.1 柯里化和偏函数的解释 即:函数返回函数 ==别的叫法==&gt; 柯里化 偏函数… 2.1.2 判断内容的类型// 判断内容的类型// Object.prototype.toString.call(‘aaa’) = ‘[object Null]’1234567// 判断类型 有四种 constructor typeof instanceof Object.prototype.toStringfunction isType(content,Type) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g,''); //String return Type === str;&#125;let result = isType('hello','String');console.log(result); //输出:true 优化,类回调函数1234567891011121314151617181920212223242526272829function isType(type) &#123; return function (content) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g, &apos;&apos;); return type === str; &#125;&#125;let util = &#123;&#125;;let type = [&apos;String&apos;,&apos;Object&apos;,&apos;Null&apos;,&apos;Function&apos;];type.forEach((item)=&gt;&#123; util[&apos;is&apos;+item] = isType(item);&#125;);console.log(util);console.log(util.isString(&apos;hello&apos;));console.log(util.isObject(&apos;Object&apos;));console.log(util.isNull(&apos;Null&apos;));console.log(util.isFunction(&apos;Function&apos;));/*输出=&gt;&#123; isString: [Function], isObject: [Function], isNull: [Function], isFunction: [Function] &#125;truefalsefalsefalse*/ 3.1 回调函数底层原理 回调函数(不一定是异步的)12345678910111213141516171819202122232425262728293031323334353637// 预置参数 lodash afterfunction after(times,callback) &#123; console.log(&apos;111****:&apos;+times); return function () &#123; console.log(&apos;222+++:&apos;+times); if(--times === 0)&#123; console.log(&apos;333====:&apos;+times); callback() &#125; &#125;&#125;let eat = after(3,function () &#123; console.log(&apos;吃完了&apos;)&#125;);eat();eat();eat();/*输出=&gt;111****:3222+++:3222+++:2222+++:1333====:0吃完了*/after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();/*输出=&gt;111****:3222+++:3111****:3222+++:3111****:3222+++:3*/ 3.1.1 回调函数的缺点 1) 异步方法如果出错了不能捕获try/catch错误2) 获取的结果不能通过return返回3) 回调函数可能会产生 (回调地狱)12345678910111213//cat 1.txt =&gt; 模板//cat 2.txt =&gt; 数据// 我们可以引用一个模块 操作文件let fs = require(&apos;fs&apos;);// 相当于两个异步请求 有关系 关系是第二个请求 是依赖于第一个的fs.readFile(&apos;./1.txt&apos;, &apos;utf8&apos;, function (err, a) &#123; // error-first fs.readFile(&apos;./2.txt&apos;, &apos;utf8&apos;, function (err, b) &#123; // error-first console.log(a, b) &#125;);&#125;);/*输出=&gt;模板 数据*/ 3.1.2 同时两个异步请求问题的规避 两个异步请求 同时拿到两个异步请求的结果1234567891011121314151617181920212223let fs = require('fs');function after(times,callback) &#123; let arr = []; return function (data) &#123; // args = [1,2,3] arr.push(data); if(--times === 0)&#123; callback(arr); &#125; &#125;&#125;let out = after(2,function (data) &#123; // [] console.log(data);&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; out(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; out(b);&#125;);/*输出=&gt;[ '模板', '数据' ]*/ 3.1.3 回调函数及发布订阅原理代码演示123456789101112131415161718192021222324252627282930313233343536373839let fs = require('fs');// 发布(这件事发生时 我要依次执行) 订阅(我预先想到的事)let events = &#123; cbs:[], results:[], on(cb)&#123; this.cbs.push(cb); &#125;, emit(data)&#123; this.results.push(data); // this.cbs.forEach(fn =&gt; fn(this.results)) this.cbs.forEach(function (fn) &#123; return fn(this.results); //这种方式是箭头函数的简写 // fn(this.results); &#125;.bind(this)); &#125;&#125;;events.on(function (data) &#123; // 订阅的过程 // if(data.length === 2)&#123; console.log(data); // &#125;&#125;);events.on(function (data) &#123; // 订阅的过程 console.log(data+' =&gt; 很棒');&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; events.emit(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; events.emit(b);&#125;);/* 输出=&gt;[ '模板' ]模板 =&gt; 很棒[ '模板', '数据' ]模板,数据 =&gt; 很棒*/ —title: 2-3.promise基础应用 date: 2018-06-17 21:59:26[TOC] 1.1promise Promises/A+规范官网https://promisesaplus.com/ 1.1.1 promise特性一 promise会立即执行12345678910console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1);&#125;);console.log(3);/*输出=&gt;213*/ 1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-3.promise基础应用]]></title>
    <url>%2F2018%2F06%2F17%2F2-3.promise%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1实现promise Promises/A+规范官网https://promisesaplus.com/ 1.1.1 promise特性一 promise会立即执行12345678910console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1);&#125;);console.log(3);/*输出=&gt;213*/ 1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 1.1.4 手写promise实现之发布订阅模式 cat 1.同步promise.js1234567891011121314151617181920212223242526272829console.log("1");let Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; console.log("3"); setTimeout(()=&gt;&#123; // resolve('买'); reject('不买'); &#125;)&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);console.log("2");/*130000000000 //过1秒钟再执行下面的2err 不买err 不买*/ 实现cat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142class Promise &#123; constructor(executor) &#123; this.status = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); //调用成功的状态 &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); //调用失败的状态 &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; if( this.status === 'pending')&#123; //发布订阅模式 console.log("00000"); this.onResolvedCallbacks.push(()=&gt;&#123; onFufilled(this.value); //一旦成功进入这个状态 &#125;); this.onRejectedCallbacks.push(()=&gt;&#123; onRejected(this.reason); //一旦失败进入这个状态 &#125;) &#125; &#125;&#125;module.exports = Promise; ##1.2 原生promise ###1.2.1 promise解决回调地狱 准备1234#cat 1.txt2.txt#cat 2.txt数据 代码详解123456789101112131415161718192021222324252627282930313233343536// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); //如果promise内部有错误,它也会走失败. fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); //这里return加不加都行,一旦失败就不会成功了 resolve(data); &#125;); &#125;)&#125;// 成功的回调 或者失败的回调执行后可以返回一个promise// 会将这个promise的执行结果传递给下一次then中// 如果返回一个普通的值 ，会将这个普通值传递到下一次then的成功的参数read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); //输出=&gt;2.txt return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); //输出=&gt; 数据 return [data];&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; [ '数据' ],这里返回值为undefined,所以下一句输出undefined&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; undefined throw new Error('xxx');&#125;) // .then() .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功&#125;) .then(data=&gt;&#123; console.log('成功'); //输出=&gt; 成功&#125;).catch(err=&gt;&#123; //一旦出错用这个捕获,它会找最近的,剩下的处理不了的都可以用catch来捕获 console.log(err)&#125;) 输出=&gt;12345672.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:25:9)成功 .then() 什么都不传使用catch捕获12345678910111213141516171819202122232425262728293031323334// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); return [data];&#125;).then(data=&gt;&#123; console.log(data);&#125;).then(data=&gt;&#123; console.log(data); throw new Error('xxx');&#125;) .then() //什么都不传 // .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) // console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功// &#125;) .then(data=&gt;&#123; console.log('成功');&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 输出=&gt;1234562.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:23:9) ###1.2.2 promise穿透 穿透的几种简写1234567891011121314151617let Promise = require('./Promise');let promise = new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;);// 成功不写的时候 默认就是value =&gt; value// 失败不写默认返回 err=&gt;&#123;throw err&#125;promise.then()//等同于// promise.then(function (data) &#123;return data&#125;)//等同于// promise.then(data =&gt; data).then(data=&gt;&#123; console.log(data);&#125;,err=&gt;&#123; console.log('err',err);&#125;)//输出=&gt; hello]]></content>
  </entry>
</search>
