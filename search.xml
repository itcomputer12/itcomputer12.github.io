<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[日志分析专题]]></title>
    <url>%2F2018%2F09%2F20%2F20180920123246%2F</url>
    <content type="text"><![CDATA[日志分析是工作中最重要的部分,如何快速的检索到自己所需要的日志信息非常的重要。重要的日志debug分析工具: http://grokdebug.herokuapp.com/ 代码演示 golang-demo12 python-demo12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git实用命令纪实]]></title>
    <url>%2F2018%2F09%2F13%2F20180913121605%2F</url>
    <content type="text"><![CDATA[本文介绍git,解释添加代码注释,及时回滚,避免今天造成的代码误删除的情况,还得从新再次写一遍 代码演示 初建仓库时12345678910111213141516171819202122232425262728Command line instructionsGit global setupgit config --global user.name &quot;YangZhenguang&quot;git config --global user.email &quot;zhenguang.yang@ele.me&quot;Create a new repositorygit clone git@git.elenet.me:zhenguang.yang/test.gitcd testtouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin masterExisting foldercd existing_foldergit initgit remote add origin git@git.elenet.me:zhenguang.yang/test.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin masterExisting Git repositorycd existing_repogit remote rename origin old-origingit remote add origin git@git.elenet.me:zhenguang.yang/test.gitgit push -u origin --allgit push -u origin --tags 代码冲突解决惨案12进行代码合并解决冲突时,特别是和同事的初始化的仓库(之前是有Git记录的,因为仓库重新创建,虽然本地的仓库有记录,但是pull只有把本地的配置给覆盖了)所以一定一定pull拉取冲突时,用rmtrash删除,并记得从回收站里把这些删除的问题备份!!!(非常重要),如上所示.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用好Cgroup用于线上生产]]></title>
    <url>%2F2018%2F09%2F12%2F20180912193700%2F</url>
    <content type="text"><![CDATA[概念Cgroup基于内核的控制案例演示 如上图所示，这里把总体资源看做一个饼图，其中资源称作”slice”，slices默认值为1024。控制资源使用有个概念为”shares”，这里的shares是在相同的cgroup组中相对对于其他资源的相对值和slice数量。这里system，User和Machine分别设置为1024slice。 System - 1024 httpd - 1024 sshd - 1024 crond - 1024 gdm - 1024 User - 1024 bash (mrichter) - 1024 bash (dorf) - 1024 Machine - 1024 testvm - 1024 在这个例子中，在单个虚拟机中，2个用户登录，有几个进程在运行。现在我们假定每个进程尽可能地使用更过的cpu。这里System/User/Machine会分别给33.333%的CPU，System中每个work会用33.333/4约8.25%的cpu时间。User中每个33.333/2约 16.5%的cpu，假如bash (mrichter)退出，bash (dorf)将可以使用33.333%的CPU。 如何设置slices的值 使用systemctl set-property 对应配置目录当用systemctl命令设置properties属性时，会在 /etc/systemd/system目录自动地生成。 如何调优? 获取当前slice的状态 systemd-cgls –no-page 提供cgroups和进程的树形运行状态. [root@wgg-bjdev-opstools-3 ~]# systemd-cgls –no-page├─1 /usr/lib/systemd/systemd –system –deserialize 21├─user.slice│ └─user-1002.slice│ ├─session-49107.scope│ │ ├─ 5873 systemd-cgls –no-page│ │ ├─13914 sshd: ops [priv]│ │ ├─13916 sshd: ops@pts/0│ │ ├─13917 -bash│ │ ├─14044 sudo -s│ │ └─14045 /bin/bash│ └─session-35831.scope│ └─10416 /usr/bin/rsync –daemon –config=/etc/rsyncd.conf└─system.slice ├─cpupresson.service │ └─25455 /home/ops/lessonsix 从输出看出,只有user.slice 和 system.slice两个top level slice,在系统上这里没有如上饼图的”Machine”所示VMs机器,所以user.slice 和 system.slice分别可获得50%的资源配额。 systemd-cgtop 类似top命令,可以实时查看resource usage使用情况,按照path,task,cpu,memory,I/O进行排序。 看到这里了 https://www.redhat.com/en/blog/world-domination-cgroups-part-2-turning-knobs 关于Cgroup设置比较基础的入门讲解：https://www.redhat.com/en/about/blog/world-domination-cgroups-part-1-cgroup-basicshttps://www.redhat.com/en/about/blog/world-domination-cgroups-part-2-turning-knobs https://www.redhat.com/en/about/blog/world-domination-cgroups-part-3-thanks-memorieshttps://www.redhat.com/en/about/blog/world-domination-cgroups-part-4-all-ios RedHat的文档手册：https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Resource_Management_Guide/chap-Using_Control_Groups.html New Control Group Interfaceshttps://www.freedesktop.org/wiki/Software/systemd/ControlGroupInterface/ Cgroup FS 数据结构https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt 内存资源配置及用例https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt I/O资源控制及用例https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt 设备白名单控制及用例https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt CPU资源控制及用例https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txthttps://www.kernel.org/doc/Documentation/cgroup-v1/cpuacct.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你手撸一个小型发布系统]]></title>
    <url>%2F2018%2F09%2F04%2F20180904121128%2F</url>
    <content type="text"><![CDATA[代码发布在一个产品生命周期中发挥着至关重要的作用,甚至可以说是伴随着一个产品的生命周期。代码发布系统有比较成熟的和其它系统集成的CI/CD系统，也有很灵活的各种插件的集成发布系统(例如jenkins)，也有小型的为了满足小规模小系统的需求的系统。最原始运维是手动的发布新的代码,然后覆盖老的代码这种方式,本文一步步带你实现如何把手动的经验累积为一个小的发布系统,释放双手,界面如上图所示。 代码演示 代码依赖:cat requirements.txt12345678910111213141516171819202122232425262728293031323334353637Babel==0.9.6backports.ssl-match-hostname==3.4.0.2chardet==2.2.1click==6.7configobj==4.7.2decorator==3.4.0Flask==0.12.2Flask-SQLAlchemy==2.0iniparse==0.4iotop==0.6itsdangerous==0.24Jinja2==2.7.2kitchen==1.1.1M2Crypto==0.21.1MarkupSafe==0.11meld3==1.0.2msgpack-python==0.4.6pycrypto==2.6.1pycurl==7.19.0pygobject==3.8.2pygpgme==0.3pyliblzma==0.5.3pyudev==0.15pyxattr==0.5.1PyYAML==3.10pyzmq==14.3.1requests==2.6.0salt==2015.5.8six==1.3.0SQLAlchemy==1.1.11supervisor==3.3.1supervisor-quick==0.1.4urlgrabber==3.10urllib3==1.10.2virtualenv==13.1.2Werkzeug==0.12.2yum-metadata-parser==1.1.4 如何使用参考: https://blog.csdn.net/loyachen/article/details/52028825]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Devops</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang之添加"Example"代码注释]]></title>
    <url>%2F2018%2F08%2F30%2F20180830124045%2F</url>
    <content type="text"><![CDATA[在编程中养成代码注释是一个非常好的习惯，一个是自己能够形成积累(很久之后再回来看自己代码的时候不至于看不懂,O(∩_∩)O哈哈~)，二是便于同行之间的交流。Golang添加代码注释非常的简单，只需要在每个函数或类前添加双斜线然后写注释即可，更加实用的方式是写的代码有例子，这样别人看你的代码一眼就知道怎么用了。下面来演示具体实现: Golang之添加注释演示 注意:这个文件应该命名为:math.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package main// math.go 文件// smath 提供一些简单的数学函数import ( "errors" "fmt")// Math 其实啥都没做type Math struct&#123; simplenumber int&#125;// Error 没有做啥的errorvar ( ErrorSimple = errors.New("simple err") ErrorNotSimple = errors.New("not simple err"))// New 创建一个Math对象func New()*Math &#123; return &amp;Math&#123;&#125; //(3)拓展:创建对象的三种方式&#125;// Deprecated: OldAdd 老旧的方法，不建议使用了func OldAdd(n1,n2 int)(int)&#123; return n1+n2&#125;// Add 两数相加//// result := Add(3,4)// result = 7//// 欢迎使用func Add(n1,n2 int)(result int)&#123; return n1+n2&#125;// Add 两数相加func (m *Math)AddOb(n1,n2 int)int&#123; return n1+n2&#125;// add 非外部方法func add(n1,n2 int) int &#123; return n1+n2&#125;func main() &#123; var mathOb = New() //(3)拓展:创建对象的三种方式 mathOb.simplenumber = 12 fmt.Printf("%+v\n",mathOb) fmt.Println(OldAdd(1,2)) //(1)注意这里注释的删除效果,见下图1 fmt.Println(Add(3,4)) //(2)注意这里代码注释的Example示例,见下图2 fmt.Println(mathOb.AddOb(5,6)) fmt.Println(add(7,8))&#125;/*输出=&gt;&amp;&#123;simplenumber:12&#125;371115*/ 图1: 图2: 对应的Add函数的代码文件,此文件命名为:math_test.go123456package mainimport &quot;fmt&quot;func ExampleAdd() &#123; //注意应该为目标函数前添加Example关键字 fmt.Println(Add(3,4)) // Output: 7&#125; Go拓展:创建对象的三种方式简化三种用法: a := &amp;user{} b := user{} c := new(user)代码如下:1234567891011121314151617181920package mainimport ( "fmt")type user struct &#123; id int `1123`&#125;func main() &#123; a := &amp;user&#123;&#125; a.id = 111 b := user&#123;&#125; b.id = 222 c := new(user) c.id = 333 fmt.Println(a, b, c)&#125;/*运行后结果如下=&gt;&amp;&#123;111&#125; &#123;222&#125; &amp;&#123;333&#125;*/ 根据输出可知: new(user)和 &amp;user{}这两种方法返回的数据都是一样的，那么这这两种数据究竟有什么不同？我们应该在什么场景使用呢？&amp;{111}返回的是实例化的对象的指针{222}返回的是一个类型]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>GolangGrammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用工具之终端颜色]]></title>
    <url>%2F2018%2F08%2F07%2F20180807093621%2F</url>
    <content type="text"><![CDATA[线上经常执行脚本时需要根据各种情况把输出内容按照颜色进行区分,效果如上,代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#/usr/bin/python#-*- coding: utf-8 -*-import datetime# 格式：\033[显示方式;前景色;背景色m# 说明:## 前景色 背景色 颜色# ---------------------------------------# 30 40 黑色# 31 41 红色# 32 42 绿色# 33 43 黃色# 34 44 蓝色# 35 45 紫红色# 36 46 青蓝色# 37 47 白色## 显示方式 意义# -------------------------# 0 终端默认设置# 1 高亮显示# 4 使用下划线# 5 闪烁# 7 反白显示# 8 不可见## 例子：# \033[1;31;40m &lt;!--1-高亮显示 31-前景色红色 40-背景色黑色--&gt;# \033[0m &lt;!--采用终端默认设置，即取消颜色设置--&gt;]]]STYLE = &#123; 'fore': &#123; # 前景色 'black' : 30, # 黑色 'red' : 31, # 红色 'green' : 32, # 绿色 'yellow' : 33, # 黄色 'blue' : 34, # 蓝色 'purple' : 35, # 紫红色 'cyan' : 36, # 青蓝色 'white' : 37, # 白色 &#125;, 'back' : &#123; # 背景 'black' : 40, # 黑色 'red' : 41, # 红色 'green' : 42, # 绿色 'yellow' : 43, # 黄色 'blue' : 44, # 蓝色 'purple' : 45, # 紫红色 'cyan' : 46, # 青蓝色 'white' : 47, # 白色 &#125;, 'mode' : &#123; # 显示模式 'mormal' : 0, # 终端默认设置 'bold' : 1, # 高亮显示 'underline' : 4, # 使用下划线 'blink' : 5, # 闪烁 'invert' : 7, # 反白显示 'hide' : 8, # 不可见 &#125;, 'default' : &#123; 'end' : 0, &#125;,&#125;def UseStyle(string, mode = '', fore = '', back = ''): mode = '%s' % STYLE['mode'][mode] if STYLE['mode'].has_key(mode) else '' fore = '%s' % STYLE['fore'][fore] if STYLE['fore'].has_key(fore) else '' back = '%s' % STYLE['back'][back] if STYLE['back'].has_key(back) else '' style = ';'.join([s for s in [mode, fore, back] if s]) style = '\033[%sm' % style if style else '' end = '\033[%sm' % STYLE['default']['end'] if style else '' return '%s%s%s' % (style, string, end)def TestColor( ): print UseStyle('正常显示') print '' print "测试显示模式" print UseStyle('高亮', mode = 'bold'), print UseStyle('下划线', mode = 'underline'), print UseStyle('闪烁', mode = 'blink'), print UseStyle('反白', mode = 'invert'), print UseStyle('不可见', mode = 'hide') print '' print "测试前景色" print UseStyle('黑色', fore = 'black'), print UseStyle('红色', fore = 'red'), print UseStyle('绿色', fore = 'green'), print UseStyle('黄色', fore = 'yellow'), print UseStyle('蓝色', fore = 'blue'), print UseStyle('紫红色', fore = 'purple'), print UseStyle('青蓝色', fore = 'cyan'), print UseStyle('白色', fore = 'white') print '' print "测试背景色" print UseStyle('黑色', back = 'black'), print UseStyle('红色', back = 'red'), print UseStyle('绿色', back = 'green'), print UseStyle('黄色', back = 'yellow'), print UseStyle('蓝色', back = 'blue'), print UseStyle('紫红色', back = 'purple'), print UseStyle('青蓝色', back = 'cyan'), print UseStyle('白色', back = 'white') print ''if __name__ == '__main__': print(datetime.datetime.now()) TestColor()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js系列之数据常用方法详解]]></title>
    <url>%2F2018%2F08%2F05%2F20180805063755%2F</url>
    <content type="text"><![CDATA[1.1.1 reduce方法12345678910var a = [1,2,3,4,5]/*求和*/var sum = a.reduce((x,y)=&gt;x+y,0);console.log(sum);/*求积*/var product = a.reduce((x,y)=&gt;x*y,1);console.log(product);/*求最大值*/var max = a.reduce((x,y)=&gt;(x&gt;y)?x:y);console.log(max);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001课件1_1-2.高阶函数]]></title>
    <url>%2F2018%2F06%2F17%2F20180617215926%2F</url>
    <content type="text"><![CDATA[[TOC] 这是一个测试 1.1开篇 1.1.1 编辑器 vscode webstorm code runner (可以片段运行代码) 1.1.2 es61.1.1.1 异步的发展流程1.1.1.1 异步和同步的区别 异步(setTimeout ajax 事件)和同步的区别: 同步表示连续执行，异步表示非连续执行 1.1.1.2 回调函数的两种表现形式 回调函数 函数(封装，私有化),即以下两种方式: (1)高阶函数,一个函数执行后返回一个函数(2)函数可以当作参数传递给另一个函数 2.1柯里化2.1.1 柯里化和偏函数的解释 即:函数返回函数 ==别的叫法==&gt; 柯里化 偏函数… 2.1.2 判断内容的类型// 判断内容的类型 // Object.prototype.toString.call(‘aaa’) = ‘[object Null]’ 1234567891011121314// 判断类型 有四种 constructor typeof instanceof Object.prototype.toStringfunction isType(content,Type) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g,''); //String return Type === str;&#125;let result = isType('hello','String');console.log(result); //输出:true 优化,类回调函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function isType(type) &#123; return function (content) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g, &apos;&apos;); return type === str; &#125;&#125;let util = &#123;&#125;;let type = [&apos;String&apos;,&apos;Object&apos;,&apos;Null&apos;,&apos;Function&apos;];type.forEach((item)=&gt;&#123; util[&apos;is&apos;+item] = isType(item);&#125;);console.log(util);console.log(util.isString(&apos;hello&apos;));console.log(util.isObject(&apos;Object&apos;));console.log(util.isNull(&apos;Null&apos;));console.log(util.isFunction(&apos;Function&apos;));/*输出=&gt;&#123; isString: [Function], isObject: [Function], isNull: [Function], isFunction: [Function] &#125;truefalsefalsefalse*/ 3.1 回调函数底层原理 回调函数(不一定是异步的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 预置参数 lodash afterfunction after(times,callback) &#123; console.log(&apos;111****:&apos;+times); return function () &#123; console.log(&apos;222+++:&apos;+times); if(--times === 0)&#123; console.log(&apos;333====:&apos;+times); callback() &#125; &#125;&#125;let eat = after(3,function () &#123; console.log(&apos;吃完了&apos;)&#125;);eat();eat();eat();/*输出=&gt;111****:3222+++:3222+++:2222+++:1333====:0吃完了*/after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();/*输出=&gt;111****:3222+++:3111****:3222+++:3111****:3222+++:3*/ 3.1.1 回调函数的缺点 1) 异步方法如果出错了不能捕获try/catch错误 2) 获取的结果不能通过return返回 3) 回调函数可能会产生 (回调地狱) 1234567891011121314151617181920212223242526//cat 1.txt =&gt; 模板//cat 2.txt =&gt; 数据// 我们可以引用一个模块 操作文件let fs = require(&apos;fs&apos;);// 相当于两个异步请求 有关系 关系是第二个请求 是依赖于第一个的fs.readFile(&apos;./1.txt&apos;, &apos;utf8&apos;, function (err, a) &#123; // error-first fs.readFile(&apos;./2.txt&apos;, &apos;utf8&apos;, function (err, b) &#123; // error-first console.log(a, b) &#125;);&#125;);/*输出=&gt;模板 数据*/ 3.1.2 同时两个异步请求问题的规避 两个异步请求 同时拿到两个异步请求的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let fs = require('fs');function after(times,callback) &#123; let arr = []; return function (data) &#123; // args = [1,2,3] arr.push(data); if(--times === 0)&#123; callback(arr); &#125; &#125;&#125;let out = after(2,function (data) &#123; // [] console.log(data);&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; out(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; out(b);&#125;);/*输出=&gt;[ '模板', '数据' ]*/ 3.1.3 回调函数及发布订阅原理代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778let fs = require('fs');// 发布(这件事发生时 我要依次执行) 订阅(我预先想到的事)let events = &#123; cbs:[], results:[], on(cb)&#123; this.cbs.push(cb); &#125;, emit(data)&#123; this.results.push(data); // this.cbs.forEach(fn =&gt; fn(this.results)) this.cbs.forEach(function (fn) &#123; return fn(this.results); //这种方式是箭头函数的简写 // fn(this.results); &#125;.bind(this)); &#125;&#125;;events.on(function (data) &#123; // 订阅的过程 // if(data.length === 2)&#123; console.log(data); // &#125;&#125;);events.on(function (data) &#123; // 订阅的过程 console.log(data+' =&gt; 很棒');&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; events.emit(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; events.emit(b);&#125;);/* 输出=&gt;[ '模板' ]模板 =&gt; 很棒[ '模板', '数据' ]模板,数据 =&gt; 很棒*/]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fs]]></title>
    <url>%2F2018%2F06%2F17%2F008%E8%AF%BE%E4%BB%B68fs%2F</url>
    <content type="text"><![CDATA[[TOC] #fs模块 ##1.1 ###1.1.1 readFile函数 readFile官网文档12cat 1.txt1234567890 cat 1.reaFile.js123456789let fs=require('fs');//是把整个文件作为一个整体fs.readFile('../1.txt',&#123;encoding:'utf8'&#125;,function (err,data) &#123; console.log(err); //输出=&gt; 1234567890 console.log(data); //输出=&gt; null&#125;);//同步方法是没有回调函数的let result=fs.readFileSync('../1.txt',&#123;encoding: 'utf8'&#125;);console.log(result); //输出=&gt; 1234567890 1.1.2 readFile函数 readFile官网文档12345678const fs=require('fs');//异步方法fs.writeFile('./2.txt','this is a test',&#123;encoding: 'utf8'&#125;,(err) =&gt; &#123; if (err) throw err; console.log('write OK');&#125;);//同步方法fs.writeFileSync('./3.txt','this is an example!!'); 1234cat ./2.txtthis is a testcat ./3.txtthis is an example!! 1.1.3 copy函数实现123456789const fs=require('fs');function copy(src,dest,cb) &#123; fs.readFile(src,(err,data) =&gt; &#123; fs.writeFile(dest,data,cb); &#125;);&#125;copy('../3.txt','../4.txt',() =&gt; &#123; //直接清空4.txt内容然后覆盖 console.log('拷贝完成');&#125;); 执行效果1234cat 3.txt456cat 4.txt456 1.1.4 向文件中追加内容的两种方式123456const fs=require('fs');//&lt;1&gt;第一种向文件中追加内容方式//writeFile flags=w 写入，如果文件已经存在，则删除掉文件后再写入fs.writeFile('./4.txt','789',&#123;flag:'a'&#125;); //打开文件用于追加。如果文件不存在则创建文件//&lt;2&gt;第二种向文件中追加内容方式fs.appendFile('./4.txt','789'); 1.1.5 open函数的fd文件描述符12345678const fs=require('fs');//fd file descriptor 文件描述符 是一个数字或者说索引fs.open('../5.txt','r',(err,fd) =&gt; &#123; console.log(fd); //输出=&gt; 11 fs.open('../4.txt','r',(err,fd) =&gt; &#123; console.log(fd); //输出=&gt; 12 &#125;);&#125;); 1.1.6 fs.open的buffer方式读取 fs.read几个参数详解12cat 6.txt饿了么外卖还行实验下 1234567891011121314151617const fs=require('fs');//1.文件太大，不能整个放到内存里边//2.文件大小未知fs.open('../6.txt','r',0666,(err,fd) =&gt; &#123; let buffer=Buffer.alloc(12);//[0,1,2,3,4,5] 只能容下3个字 fs.read(fd,buffer,0,12,9,(err,bytesRead) =&gt; &#123; //length读取的字节不够的话剩下的会乱码 /* 1.从 fd 指定的文件中读取数据。 2.buffer 是数据将被写入到的 buffer。 3.offset 是 buffer 中开始写入的偏移量。 4.length 是一个整数，指定要读取的字节数。 5.position 指定从文件中开始读取的位置。 如果 position 为 null， 则数据从当前文件读取位置开始读取，且文件读取位置会被更新。 如果 position 为一个整数，则文件读取位置保持不变。 */ console.log(buffer.toString()); //输出=&gt; 外卖还行 &#125;);&#125;); 进一步解释:1234567891011const fs=require('fs');fs.open('../6.txt','r',0666,(err,fd) =&gt; &#123; let buffer=Buffer.alloc(12);//读取4个字的长度 //从第3个字节开始读,即从"了"开始读,读取一个字 fs.read(fd,buffer,0,6,9,(err,bytesRead) =&gt; &#123; //读取"外卖" //从第6个字节开始读,即从"么"开始读,读取一个字,并向后移动一个字,即3字节 fs.read(fd,buffer,6,6,15,(err,byteRead) =&gt; &#123; //在buffer中偏移"外卖"2个字6字节的长度,从"还行"15字节出开始读2个字的长度 console.log(buffer.toString()); &#125;); &#125;);&#125;); 1.1.7 fs的write/fsync/close用法举例 cat ../6.txt饿了么外卖还行实验下cat 7.write.js12345678910111213141516171819202122232425262728293031const fs=require('fs');fs.open('../6.txt','r+',0666,(err,fd) =&gt; &#123; // let buffer=Buffer.alloc(12); let buffer=Buffer.from('饿了么好');//[0,1,2,3,4,5,6,7,8,9,10,11] //fd buffer offset /* 1-2.写入 buffer 到 fd 指定的文件。 3.offset 决定 buffer 中被写入的部分。 4.length 是一个整数，指定要写入的字节数。 5.position 指向从文件开始写入数据的位置的偏移量。 如果 typeof position !== 'number'，则数据从当前位置写入。详见 pwrite(2)。 6.回调有三个参数 (err, bytesWritten, buffer)，其中 bytesWritten 指定从 buffer 写入了多少字节。 */ fs.write(fd,buffer,3,6,3,(err,bytesWritten) =&gt; &#123; // console.log(err); //没有错误,输出=&gt; null console.log(bytesWritten); //这里的"bytesWritten"为length,即6(指定从 buffer 写入了多少字节) fs.fsync(fd,(err) =&gt; &#123; //fsync从内存刷新到磁盘 fs.close(fd,(err) =&gt; &#123; console.log('关闭文件'); &#125;); &#125;); &#125;);&#125;);/*let a=10; //10进制let b=0x10; //16进制let c=011; //8进制let d=0b11; //2进制console.log(c); //输出=&gt; 9console.log(d); //输出=&gt; 3*/ 1.1.8 cat ../6.txt || 7.txt饿了么外卖还行实验下123456789101112131415161718192021222324252627282930const fs=require('fs');const BUFFER_SIZE=3;//src 5function copy(src,dest) &#123; fs.open(src,'r',(err,readFd)=&gt; &#123; fs.open(dest,'w',(err,writeFd) =&gt; &#123; let buffer=Buffer.alloc(BUFFER_SIZE); let readed=0; let writed=0; function next() &#123; fs.read(readFd,buffer,0,BUFFER_SIZE,readed,(err,bytesRead) =&gt; &#123; readed+=bytesRead; bytesRead&amp;&amp;fs.write(writeFd,buffer,0,bytesRead,writed,(err,bytesWritten) =&gt; &#123; writed+=bytesWritten; next(); &#125;); &#125;); &#125;; next(); &#125;); &#125;);&#125;copy('../6.txt','7.txt');function f(err,bytesRead,flag) &#123; console.log(err); flag&amp;&amp;console.log(bytesRead);&#125;f("err",12, true) //输出=&gt; err 12//f("err",12) //输出=&gt; err 1.1.9 mkdir命令实现 cat 9.mkdir.js123456789101112131415let fs=require('fs');let path=require('path');//如何创建一个目录,创建目录的时候要求父目录必须存在,即这里的a/b目录必须存在fs.mkdir('./a/b/c',err =&gt; &#123; console.log(err); console.log('创建成功');&#125;);//判断一个文件是否存在/*fs.access('./7.tx',(err) =&gt; &#123; console.log(err); //&#123; [Error: ENOENT: no such file or directory, access './7.tx'] // errno: -2, code: 'ENOENT', syscall: 'access', path: './7.tx' &#125;&#125;);*/ 1.1.10 执行一个函数123!function next() &#123; //~和!都可 console.log(1);&#125;(); 1.1.11 call和apply的区别 如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。12345678910function fn(a,b) &#123; // console.log(this); //打印全局global console.log(a, b);&#125;fn.call(null,1,2); //参数fn.apply(null,[1,2]); //参数为数组/*输出=&gt;1 21 2*/ 1.1.12 apply 和 call 的用法参考 1.1.12.1 改变 this 指向1234567var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;func.call(obj); //输出=&gt;linxin 我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于123function func() &#123; console.log(obj.name);&#125; 1.1.12.2 借用别的对象的方法 从下面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。123456789101112131415161718var Person1 = function () &#123; this.name = 'linxin';&#125;var Person2 = function () &#123; console.log(this); this.getname = function () &#123; console.log(this); console.log(this.name); &#125; Person1.call(this); //相当于类的继承extends,使用 Person1 对象代替 this 对象&#125;var person = new Person2();person.getname(); /*Person2 &#123;&#125;Person2 &#123; getname: [Function], name: 'linxin' &#125;linxin*/ 1.1.13 call 和 bind 的区别 在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。它们之间的区别有以下两点。 1.1.13.1 调用函数1234567891011var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this); console.log(this.name);&#125;var func1 = func.bind(obj);func1(); //输出=&gt; linxin bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。 1.1.13.2 调用函数 call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。123456789function func(a, b, c) &#123; console.log(a, b, c);&#125;var func1 = func.bind(null,'linxin');func('A', 'B', 'C'); // A B Cfunc1('A', 'B', 'C'); // linxin A Bfunc1('B', 'C'); // linxin B Cfunc.call(null, 'linxin'); // linxin undefined undefined 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。1234567891011121314151617if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125;function f() &#123; console.log([].slice.call(arguments))&#125;f(1,2,3); //输出=&gt; [ 1, 2, 3 ]let test = f.bind(this);test(1,2,3); //输出=&gt; [ 1, 2, 3 ]]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础]]></title>
    <url>%2F2018%2F06%2F17%2F004%E8%AF%BE%E4%BB%B61_3node%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC]# 1.11.1.1多线程 多线程 单线程 主线程是单线程的 (node其实也是多线程的 setTimeout线程 ajax)浏览器 (线程 进程) js线程 ui线程一般情况下 ui线程 渲染后 空闲下来 会执行jsjs线程和ui线程 是共享线程的( webworker 进程) 开一个工作者(归主线程来管理的，不能操作dom)如果js是多线程的,不能同时两个线程 操作同一个DOM异步 同步阻塞和非阻塞NODE非阻塞异步io + 事件驱动queue stack queue队列 先进先出 push shift stack栈 函数执行 ive-server / http-server/ zf-http-server 全局安装12npm install http-server -ghttp-server 1.1.1.1 宏任务MutationObserve更新示例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;/div&gt; &lt;script&gt; // 废弃了 兼容有问题 let observe = new MutationObserver(function () &#123; alert('已经dom更新好了') &#125;); observe.observe(app,&#123;childList:true&#125;); for(let i = 0;i&lt;1000;i++)&#123; app.appendChild(document.createElement('span')); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 1.1.1.2 h5内置函数同异步代码演示1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 宏任务 MutationObserve let messageChannel = new MessageChannel(); //h5内置 let prot2 = messageChannel.port2; // postMessage是异步执行的 要等待同步都执行完后 才会被调用 messageChannel.port1.postMessage('我爱你'); console.log(1); prot2.onmessage = function (e) &#123; console.log(e.data); &#125; console.log(2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器Console输出12312我爱你 1.1.2.1 多线程工作原理代码详解 cat 1.webworker.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 多线程 可以开一个工作线程 // 但是要归主线程所管理 // websocket let worker = new Worker('./1.worker.js'); worker.postMessage(10000); worker.onmessage = function (e) &#123; console.log(e.data); &#125; console.log('main thread') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器Console输出12main thread49995000 cat 1.worker.js 写完后通过消息发送给另一个线程12345678onmessage = function (e) &#123; let r = e.data; let sum = 0; for(var i = 0;i&lt;r;i++)&#123; sum+=i; &#125; postMessage(sum);&#125; 1.1.2.2 主线程栈调用顺序12345678910111213141516function one() &#123; console.log(1); function two()&#123; console.log(2); function three() &#123; console.log(3); &#125; three(); &#125; two();&#125;one();/*输出=&gt;123*/ 1.1.2.2 放入回调队列顺序的代码演示123456789101112131415161718192021222324//同步代码执行后 才会执行异步// 根据时间排序 当时间到达后 把对应的回调 放到队列里// 宏任务 微任务(vue $nextTick) 异步方法// setImmedate只兼容ie setTimeout(() =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(4); &#125;, 1000); //这个比2后放入callback queue的&#125;, 1000);setTimeout(() =&gt; &#123; console.log(2);&#125;, 2000);setTimeout(() =&gt; &#123; console.log(3);&#125;, 3000);/*输出=&gt;1243*/ 1.1.2.3 微任务和宏任务执行顺序 Promise中的then方法是微任务 会在宏任务之前执行cat Promise.html1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log(1); // Promise中的then方法是微任务 会在宏任务之前执行 let p = new Promise( (resolve,reject)=&gt; &#123; console.log(2); resolve(); &#125;); setTimeout(() =&gt; &#123; //宏任务 console.log('timeout') &#125;, 0); p.then(data=&gt;&#123; //微任务 console.log(3); &#125;) console.log(4); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器Console输出123451243timeout setImmediate也是宏任务123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 默认是低于timeout 宏任务 setImmediate(function () &#123; //只有2B的微软有这个方法(宏任务) console.log('setImmediate') &#125;) setTimeout(function () &#123; console.log('timeout') &#125;, 4); console.log(1); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--输出=&gt;1setImmediatetimeout--&gt; 1.1.2.4 微任务和宏任务复杂场景比较执行顺序 cat timeout.js123456789101112131415161718setTimeout(() =&gt; &#123; console.log('setTimeout1') Promise.resolve().then(data =&gt; &#123; console.log('微任务1') &#125;)&#125;, 0);Promise.resolve().then(data=&gt;&#123; console.log('微任务2') setTimeout(() =&gt; &#123; console.log('setTimeout2') &#125;, 0);&#125;);/*输出=&gt;输出顺序不一致微任务2setTimeout1微任务1 (不一定前后)setTimeout2 (不一定前后)*/]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02课件3_3-6.promise基础应用及链式写法和实现和promise其他用法]]></title>
    <url>%2F2018%2F06%2F17%2F002%E8%AF%BE%E4%BB%B63_3-6.promise%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%8F%8A%E9%93%BE%E5%BC%8F%E5%86%99%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%92%8Cpromise%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1实现promise Promises/A+规范官网https://promisesaplus.com/ 1.1.1 promise特性一 promise会立即执行12345678910console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1);&#125;);console.log(3);/*输出=&gt;213*/ 1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 1.1.4 手写promise实现之发布订阅模式 cat 1.同步promise.js1234567891011121314151617181920212223242526272829console.log("1");let Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; console.log("3"); setTimeout(()=&gt;&#123; // resolve('买'); reject('不买'); &#125;)&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);console.log("2");/*130000000000 //过1秒钟再执行下面的2err 不买err 不买*/ 实现cat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142class Promise &#123; constructor(executor) &#123; this.status = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); //调用成功的状态 &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); //调用失败的状态 &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; if( this.status === 'pending')&#123; //发布订阅模式 console.log("00000"); this.onResolvedCallbacks.push(()=&gt;&#123; onFufilled(this.value); //一旦成功进入这个状态 &#125;); this.onRejectedCallbacks.push(()=&gt;&#123; onRejected(this.reason); //一旦失败进入这个状态 &#125;) &#125; &#125;&#125;module.exports = Promise; ##1.2 原生promise ###1.2.1 promise解决回调地狱 准备1234#cat 1.txt2.txt#cat 2.txt数据 代码详解123456789101112131415161718192021222324252627282930313233343536// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); //如果promise内部有错误,它也会走失败. fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); //这里return加不加都行,一旦失败就不会成功了 resolve(data); &#125;); &#125;)&#125;// 成功的回调 或者失败的回调执行后可以返回一个promise// 会将这个promise的执行结果传递给下一次then中// 如果返回一个普通的值 ，会将这个普通值传递到下一次then的成功的参数read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); //输出=&gt;2.txt return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); //输出=&gt; 数据 return [data];&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; [ '数据' ],这里返回值为undefined,所以下一句输出undefined&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; undefined throw new Error('xxx');&#125;) // .then() .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功&#125;) .then(data=&gt;&#123; console.log('成功'); //输出=&gt; 成功&#125;).catch(err=&gt;&#123; //一旦出错用这个捕获,它会找最近的,剩下的处理不了的都可以用catch来捕获 console.log(err)&#125;) 输出=&gt;12345672.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:25:9)成功 .then() 什么都不传使用catch捕获12345678910111213141516171819202122232425262728293031323334// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); return [data];&#125;).then(data=&gt;&#123; console.log(data);&#125;).then(data=&gt;&#123; console.log(data); throw new Error('xxx');&#125;) .then() //什么都不传 // .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) // console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功// &#125;) .then(data=&gt;&#123; console.log('成功');&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 输出=&gt;1234562.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:23:9) ###1.2.2 promise穿透 穿透的几种简写1234567891011121314151617let Promise = require('./Promise');let promise = new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;);// 成功不写的时候 默认就是value =&gt; value// 失败不写默认返回 err=&gt;&#123;throw err&#125;promise.then()//等同于// promise.then(function (data) &#123;return data&#125;)//等同于// promise.then(data =&gt; data).then(data=&gt;&#123; console.log(data);&#125;,err=&gt;&#123; console.log('err',err);&#125;)//输出=&gt; hello ###1.2.3 promise A+测试规范npm install promises-aplus-tests -g 全局安装➜ promise-public-6-9 git:(master) ✗ promises-aplus-tests Promise.js #执行是否符合promiseA+检测12345678 The value is `1` with `Number.prototype` modified to have a `then` method ✓ already-fulfilled ✓ immediately-fulfilled ✓ eventually-fulfilled ✓ already-rejected ✓ immediately-rejected ✓ eventually-rejected872 passing (24s) 2.1 promise其他用法 自己实现的promisecat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165class Promise &#123; constructor(executor) &#123; this.status = &apos;pending&apos;; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;resolved&apos;; this.value = value; this.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;rejected&apos;; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 如果出现异常就走错误处理 &#125; &#125; then(onFufilled, onRejected) &#123; // 默认成功和失败不传的情况 onFufilled = typeof onFufilled === &apos;function&apos; ? onFufilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let promise2; promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === &apos;resolved&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;rejected&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;pending&apos;) &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;) &#125; &#125;); return promise2; &#125; catch(fn)&#123; return this.then(null,fn); &#125;&#125;Promise.all = (promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index = 0; let processData = (key, y) =&gt; &#123; index++ result[key] = y; if (promises.length === index) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; processData(i, y); &#125;, reject); &#125; &#125;)&#125;Promise.race =(promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;Promise.resolve = function (data) &#123; return new Promise((resolve,reject)=&gt;&#123; resolve(data); &#125;)&#125;Promise.reject = function (data) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(data); &#125;)&#125;// 实现多套promise共用的情况function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError(&apos;循环引用&apos;)); &#125; // &#123;then:&#123;&#125;&#125; let called; if (x != null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;)) &#123; try &#123; let then = x.then; // 如果是对象 我就试着取一下then方法 if (typeof then === &apos;function&apos;) &#123; // 就是promise了 then.call(x, y =&gt; &#123; // 成功和失败只能调用一个 if (called) return; called = true; // resolve的结果依旧是promise 那就继续解析 resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; called = true; reject(r);// 失败了就失败了 &#125;) &#125; else &#123; resolve(x); // 直接成功即可 &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); // 取then出错了那就不要在继续执行了 &#125; &#125; else &#123; resolve(x); &#125;&#125;// 目前是通过他测试 他会测试一个对象// 语法糖Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise;// npm install promises-aplus-tests -g// promises-aplus-tests ###2.1.1 defer源码实现及用法.js 引用123456789101112131415let fs = require('fs');// Q库let Promise = require('./Promise.js');function read(path, encoding) &#123; let dfd = Promise.defer(); fs.readFile(path, encoding, function (err, data) &#123; if (err) return dfd.reject(err); dfd.resolve(data); &#125;); return dfd.promise;&#125;read('1.txt','utf8').then(data =&gt; &#123; console.log(data);&#125;)//输出=&gt; 2.txt ###2.1.2 catch源码实现及用法.js 引用1234567891011121314151617let Promise = require(&apos;./Promise&apos;)let promise = new Promise((resove,reject)=&gt;&#123; reject(&apos;错误&apos;);&#125;)// 当前catch里只接受错误promise.then(null).catch(err=&gt;&#123; console.log(&apos;2&apos;,err);&#125;);Promise.resolve(&apos;123&apos;).then(data=&gt;&#123; console.log(data);&#125;)// 实现promise finaly是如何实现的/* 输出=&gt;1232 错误*/ ###2.1.3 All方法源码实现及用法.js 引用面试:如何实现all和race源码all:所有方法都成功才成功,否则失败。race为一个成功就成功,一个失败就失败。这里new promise用的是原生的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;function all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index =0; let processData = (key, y) =&gt; &#123; index++ //每处理一次+1 result[key] = y; if (promises.length === index)&#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; //使用then调用promise的all里面的方法 processData(i, y); //i为位置,y为函数的返回值 &#125;, reject); //失败直接reject &#125; &#125;)&#125;//race为一个成功就成功,一个失败就失败function race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;all([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; [ '2.txt', '数据' ]race([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; 2.txt/*cat 1.txt2.txtcat 2.txt数据*/ ###2.1.4 promisify及promisifyAll使每个方法都会多一个promise的方法 实现,参考bluebird这个库123456789101112131415161718192021222324252627// npm install bluebird// let bluebird = require('bluebird');let fs = require('fs');function promisifyAll(obj) &#123; // console.log(Object.keys(obj)); //可以拿到obj下面的所有方法,所有方法变成数组 Object.keys(obj).forEach(item=&gt;&#123; if (typeof obj[item] === 'function')&#123; // 把每一个函数 都promise化一下 ，每个方法都会多一个promise的方法 obj[item + 'Async'] = promisify(obj[item]); &#125; &#125;);&#125;promisifyAll(fs);function promisify(readFile) &#123; return function (...args) &#123; return new Promise((resolve,reject)=&gt;&#123; readFile(...args,function (err,data) &#123; if(err) reject(err); resolve(data); &#125;) &#125;); &#125;&#125;// let read = promisify(fs.readFile); // 就会返回一个promise方法fs.readFileAsync('1.txt','utf8').then(data=&gt;&#123; console.log(data);&#125;)//输出=&gt; 2.txt]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[generator+async-wait]]></title>
    <url>%2F2018%2F06%2F17%2F003%E8%AF%BE%E4%BB%B67_7.generator%2Basync-wait%2F</url>
    <content type="text"><![CDATA[[TOC] generator+async await1.1 源码讲解 redux-saga koa1.0 generator --&gt; kos async await 1.1.1 是否可迭代比较 1234567891011let arr = &#123; 0: 1, 1: 2, length: 2&#125; //给类数组增加可迭代的函数才可以迭代for (let item of arr)&#123; //报错=&gt; TypeError: arr is not iterable// for (let item of [1,2,3])&#123; console.log(item);&#125; //输出=&gt; 1 2 3function a()&#123; for (let item of arguments)&#123; //arguments不是数组 console.log(item) &#125;&#125;a(1,2,3) //输出=&gt; 1 2 3 1.1.2实现迭代器 生成器返回的是迭代器 迭代器:迭代器必须返回一个对象对象里有一个next方法，每调用一次next方法就可以返回一个对象。 done表示是否迭代完成, value表示为迭代的结果。 123456789101112131415let arr = &#123; 0: 1, 1: 2, length: 2 ,[Symbol.iterator]:function () &#123; let len = this.length; let index = 0; let that = this; return &#123; next()&#123; return &#123; done: index === len, value: that[index++]&#125; &#125; &#125;&#125;&#125;;for (let item of arr)&#123; console.log(item);&#125; //输出=&gt; 1 2 1.1.2 generator的”*”和”yeild” generator 必须要有* 配合yeild ,碰到yield 就停止，再次调用next就继续走当遇到return时就迭代完成了第一个next传递参数是没有效果的第二次next传递的参数 是第一次yield的返回值原理图解:1234567891011121314151617function * thing() &#123; let a = yield 1; return a; console.log(a); let b = yield 2; console.log(b); &#125;let it = thing();// console.log(it.next());console.log(it.next('2000'));console.log(it.next('4000'));console.log(it.next('end000'));/*输出=&gt;&#123; value: 1, done: false &#125;&#123; value: '4000', done: true &#125;&#123; value: undefined, done: true &#125;*/ 1.1.3 generator应用案例之promisify1234cat 1.txt2.txtcat 2.txt我很帅 实现123456789101112131415let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);function* readMethod() &#123; let data1 = yield read('./1.txt','utf8'); let data2 = yield read(data1,'utf8'); return data2;&#125;let it = readMethod();it.next().value.then(data =&gt; &#123; it.next(data).value.then(data =&gt; &#123; let &#123; done, value &#125; = it.next(data); console.log(done,value); //输出=&gt; true '我很帅' &#125;)&#125;) 1.1.3 async+await等价的“generator+co库”的实现async+await &lt;==&gt; generator+co库 改进以及开源co库的实现1234567891011121314151617181920212223242526272829303132333435363738let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);function* readMethod() &#123; let data1 = yield read('./1.txt','utf8'); let data2 = yield read(data1,'utf8'); return data2;&#125;/*let it = readMethod();it.next().value.then(data =&gt; &#123; it.next(data).value.then(data =&gt; &#123; let &#123; done, value &#125; = it.next(data); console.log(done,value); &#125;)&#125;)*/function co(it) &#123; //开源co库的实现 return new Promise((resolve, reject)=&gt;&#123; // 异步调用的问题 function next(data)&#123; let &#123; value, done &#125; = it.next(data); if(!done)&#123; value.then(data =&gt; &#123; next(data) &#125;, reject) &#125;else&#123; resolve(value); &#125; &#125; next(); &#125;)&#125;// let co = require('co'); //generator async =&gt; async flow generator coro coroutine//git地址:https://github.com/tj/co tj为express作者// 获取1.txt内容 2.txt 2.txt放的内容是最终的结果co(readMethod()).then(data=&gt;&#123; console.log(data); //输出=&gt; 我很帅&#125;) 1.1.4 async+await使用123456789101112//这就是一个语法糖let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);async function readMethod() &#123; let data1 = await read('./1.txt','utf8'); let data2 = await read(data1,'utf8'); return data2;&#125;readMethod().then(data=&gt;&#123; console.log(data); //输出=&gt; 我很帅&#125;) 通过babeljs.io转译后async和await的源码实现,function _asyncToGenerator(fn)函数部分(同function co(it))http://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=IYZwngdgxgBAZgV2gFwJYHsIwE4FNgAmAsrsgBboEAUAlDAN4BQMMANqTAcMsAIwwBeGMADuwVMhz5qAcgB0Ael5zkAD2QyANDITI4ADhk0A3MzYcuPAEyDhYiVMJVLfbboNHTLPMgTYsLlamAL5AA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion= 1.2 实际应用 一共四种实现方式 1.2.1 callback方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; /* *表示匹配所有 */ margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; /* 中间差10px*/ left: 0; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div style="position: relative"&gt; &lt;!--这里表示是在同一个轴上--&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); let ball1 = document.getElementById('ball1'); let ball2 = document.getElementById('ball2'); console.log(typeof $); function move(el, target, cb) &#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer); return cb(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;/* move($('#ball1'), 500, function () &#123; move($('#ball2'), 500, function () &#123; alert('移动完成') &#125;) &#125;)*/ move(ball1, 300, function () &#123; move(ball2, 300, function () &#123; alert('移动完成') &#125;) &#125;) /*move($('#ball1'), 500, function () &#123; //第一种方式：回调 move($('#ball2'), 500, function () &#123; alert('移动完成') &#125;) &#125;)*/ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.2.2 Promise方式 Promise的链式写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;) &#125; move($('#ball1'), 500).then(data=&gt;&#123; return move($('#ball2'), 500) &#125;).then(data=&gt;&#123; /*链式写法,根据上边的返回值*/ alert('ok'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.3 generator+co库方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); //3s超时 &#125;) &#125; function *m() &#123; yield move($('#ball1'),500); yield move($('#ball2'),500); &#125; function co(it) &#123; return new Promise((resolve,reject)=&gt;&#123; function next(data) &#123; let &#123;value ,done&#125; = it.next(data); console.log(done) if(!done)&#123; value.then(data=&gt;&#123; next(data); &#125;,reject); &#125; else &#123; resolve(data); &#125; &#125; next(); &#125;) &#125; co(m()).then(data=&gt;&#123; alert('成功'); &#125;,err=&gt;&#123; console.log(err); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.3 async+await方式 async和await可以支持 try catch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; // throw new Error(); return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve();; &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;) &#125; // async和await可以支持 try catch async function m() &#123; // try&#123; await move($('#ball1'), 500); await move($('#ball2'), 500); // &#125;catch(e)&#123; // console.log(e); // &#125; &#125; m().then(data=&gt;&#123; alert('成功'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 所有效果如下]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
