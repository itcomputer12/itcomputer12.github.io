<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2-1/2.高阶函数]]></title>
    <url>%2F2018%2F06%2F17%2F2-1%3A2.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1开篇1.1.1 编辑器 vscode webstorm code runner (可以片段运行代码)1.1.2 es6 1.1.1.1 异步的发展流程1.1.1.1 异步和同步的区别 异步(setTimeout ajax 事件)和同步的区别:同步表示连续执行，异步表示非连续执行1.1.1.2 回调函数的两种表现形式 回调函数 函数(封装，私有化),即以下两种方式:(1)高阶函数,一个函数执行后返回一个函数(2)函数可以当作参数传递给另一个函数 2.1柯里化2.1.1 柯里化和偏函数的解释 即:函数返回函数 ==别的叫法==&gt; 柯里化 偏函数… 2.1.2 判断内容的类型// 判断内容的类型// Object.prototype.toString.call(‘aaa’) = ‘[object Null]’1234567// 判断类型 有四种 constructor typeof instanceof Object.prototype.toStringfunction isType(content,Type) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g,''); //String return Type === str;&#125;let result = isType('hello','String');console.log(result); //输出:true 优化,类回调函数1234567891011121314151617181920212223242526272829function isType(type) &#123; return function (content) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g, &apos;&apos;); return type === str; &#125;&#125;let util = &#123;&#125;;let type = [&apos;String&apos;,&apos;Object&apos;,&apos;Null&apos;,&apos;Function&apos;];type.forEach((item)=&gt;&#123; util[&apos;is&apos;+item] = isType(item);&#125;);console.log(util);console.log(util.isString(&apos;hello&apos;));console.log(util.isObject(&apos;Object&apos;));console.log(util.isNull(&apos;Null&apos;));console.log(util.isFunction(&apos;Function&apos;));/*输出=&gt;&#123; isString: [Function], isObject: [Function], isNull: [Function], isFunction: [Function] &#125;truefalsefalsefalse*/ 3.1 回调函数底层原理 回调函数(不一定是异步的)12345678910111213141516171819202122232425262728293031323334353637// 预置参数 lodash afterfunction after(times,callback) &#123; console.log(&apos;111****:&apos;+times); return function () &#123; console.log(&apos;222+++:&apos;+times); if(--times === 0)&#123; console.log(&apos;333====:&apos;+times); callback() &#125; &#125;&#125;let eat = after(3,function () &#123; console.log(&apos;吃完了&apos;)&#125;);eat();eat();eat();/*输出=&gt;111****:3222+++:3222+++:2222+++:1333====:0吃完了*/after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();/*输出=&gt;111****:3222+++:3111****:3222+++:3111****:3222+++:3*/ 3.1.1 回调函数的缺点 1) 异步方法如果出错了不能捕获try/catch错误2) 获取的结果不能通过return返回3) 回调函数可能会产生 (回调地狱)12345678910111213//cat 1.txt =&gt; 模板//cat 2.txt =&gt; 数据// 我们可以引用一个模块 操作文件let fs = require(&apos;fs&apos;);// 相当于两个异步请求 有关系 关系是第二个请求 是依赖于第一个的fs.readFile(&apos;./1.txt&apos;, &apos;utf8&apos;, function (err, a) &#123; // error-first fs.readFile(&apos;./2.txt&apos;, &apos;utf8&apos;, function (err, b) &#123; // error-first console.log(a, b) &#125;);&#125;);/*输出=&gt;模板 数据*/ 3.1.2 同时两个异步请求问题的规避 两个异步请求 同时拿到两个异步请求的结果1234567891011121314151617181920212223let fs = require('fs');function after(times,callback) &#123; let arr = []; return function (data) &#123; // args = [1,2,3] arr.push(data); if(--times === 0)&#123; callback(arr); &#125; &#125;&#125;let out = after(2,function (data) &#123; // [] console.log(data);&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; out(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; out(b);&#125;);/*输出=&gt;[ '模板', '数据' ]*/ 3.1.3 回调函数及发布订阅原理代码演示123456789101112131415161718192021222324252627282930313233343536373839let fs = require('fs');// 发布(这件事发生时 我要依次执行) 订阅(我预先想到的事)let events = &#123; cbs:[], results:[], on(cb)&#123; this.cbs.push(cb); &#125;, emit(data)&#123; this.results.push(data); // this.cbs.forEach(fn =&gt; fn(this.results)) this.cbs.forEach(function (fn) &#123; return fn(this.results); //这种方式是箭头函数的简写 // fn(this.results); &#125;.bind(this)); &#125;&#125;;events.on(function (data) &#123; // 订阅的过程 // if(data.length === 2)&#123; console.log(data); // &#125;&#125;);events.on(function (data) &#123; // 订阅的过程 console.log(data+' =&gt; 很棒');&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; events.emit(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; events.emit(b);&#125;);/* 输出=&gt;[ '模板' ]模板 =&gt; 很棒[ '模板', '数据' ]模板,数据 =&gt; 很棒*/]]></content>
  </entry>
</search>
