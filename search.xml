<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F06%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[[TOC] #1 继承 ##1.1 如何实现一个类？ 类的继承 三种属性 公有属性(proto) 私有属性 静态方法(静态属性) ###1.1.1公有属性(proto)及私有属性12345678910111213141516171819202122232425function Parent()&#123; // 构造函数中的this 通过new调用的那么this指代的是实例 this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;// 1)console.log(Parent.prototype.constructor ===Parent); //输出:true// 2)let parent = new Parent();parent.__proto__.eat(); //输出:eat 会先去找私有属性找不到再去找公有属性function Child() &#123; this.age = 9; Parent.call(this); //等价于 this.name = 'parent';&#125;let child = new Child();console.log(child.__proto__.constructor == Child); //输出:trueconsole.log(typeof child.constructor); //输出:functionconsole.log(Child.age); //拿属性应该通过实例child.ageconsole.log(child.age); //输出:9// 一.继承私有属性 Parent.call(this);console.log(child.name); //输出:parent 图解 ###1.1.2 类的继承 ###1.1.2.1 继承的错误的用法123456789101112131415161718192021222324function Parent()&#123; this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;function Child() &#123; this.age = 9; Parent.call(this);&#125;//错误写法Child.prototype = Parent.prototype; //指向同一个,儿子改父亲也会改,比较危险,不推荐这么搞。不是父子成兄弟了,共享一个媳妇,乱套了// 继承公有属性和私有属性// Child.prototype = new Parent(); // 不会使用这种方式Child.prototype.smoking = function ()&#123; console.log('吸烟');&#125;let child = new Child();child.eat(); //输出:eatChild.prototype.a = 100;let parent = new Parent();console.log(parent.a); //输出:100 图解 ###1.1.2.2 继承的正确的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Parent()&#123; this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;function Child() &#123; this.age = 9; Parent.call(this);&#125;Child.prototype.smoking = function ()&#123; console.log('吸烟');&#125;//1）正确写法:// Child.prototype.__proto__ = Parent.prototype; //老的写法// Object.setPrototypeOf(Child.prototype, Parent.prototype); //ES6写法。等同于上一句的写法,这个种使用方式更正规,效果一样//2）只继承公有属性://实现Object.create()function create(parentPrototype)&#123; function Fn()&#123;&#125; //Fn()是实例,得等它去原型上找 Fn.prototype = parentPrototype; return new Fn();&#125;Child.prototype = create(Parent.prototype);// Child.prototype = Object.create(Parent.prototype);let child = new Child();child.eat(); // 输出:eatconsole.log(child.constructor); // 输出:[Function: Parent]//3）继承Child://实现Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);function create(parentPrototype,props)&#123; function Fn() &#123;&#125; Fn.prototype = parentPrototype; let fn = new Fn(); for(let key in props)&#123; Object.defineProperty(fn, key, &#123; ...props[key], enumerable:true &#125;); &#125; return fn;&#125;/*Child.prototype = Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);let child = new Child();console.log(child.constructor); //输出:[Function: Child]*/ (1)相当于建了一个空的构造函数,指向父类的原型,相当于一个中转。(2)改变实例,父亲的原型不变。这里parentPrototype最终指向Parent类,也就是child.constructor指向Parent类。 ##1.2 ###1.2.1 Object.defineProperty()方法详解1234567891011121314151617let a = &#123;&#125;// a.name = 1;// ES5Object.defineProperty(a, 'name', &#123; enumerable: true, // 表示这个属性是否可以被枚举出来 configurable: true, // 表示这个属性是否可被删除 // writable:true, //是否这个属性能够被改 get() &#123; // value可以替换成set和get console.log('get'); return 1; &#125;, set(val) &#123; console.log('设置值') &#125;&#125;);console.log(a.name); //输出: get 1a.name = 200;//输出: 设置值]]></content>
  </entry>
  <entry>
    <title><![CDATA[arunyang_markdown]]></title>
    <url>%2F2018%2F06%2F16%2Farunyang-markdown%2F</url>
    <content type="text"></content>
  </entry>
</search>
