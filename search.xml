<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F06%2F26%2F2%EF%BB%BF_7.generator%2Basync-wait%2F</url>
    <content type="text"><![CDATA[[TOC] generator+async await1.1 源码讲解 redux-saga koa1.0 generator --&gt; kos async await 1.1.1 是否可迭代比较 1234567891011let arr = &#123; 0: 1, 1: 2, length: 2&#125; //给类数组增加可迭代的函数才可以迭代for (let item of arr)&#123; //报错=&gt; TypeError: arr is not iterable// for (let item of [1,2,3])&#123; console.log(item);&#125; //输出=&gt; 1 2 3 function a()&#123; for (let item of arguments)&#123; //arguments不是数组 console.log(item) &#125;&#125;a(1,2,3) //输出=&gt; 1 2 3 1.1.2实现迭代器 生成器返回的是迭代器 迭代器:迭代器必须返回一个对象对象里有一个next方法，每调用一次next方法就可以返回一个对象。 done表示是否迭代完成, value表示为迭代的结果。 123456789101112131415let arr = &#123; 0: 1, 1: 2, length: 2 ,[Symbol.iterator]:function () &#123; let len = this.length; let index = 0; let that = this; return &#123; next()&#123; return &#123; done: index === len, value: that[index++]&#125; &#125; &#125;&#125;&#125;;for (let item of arr)&#123; console.log(item);&#125; //输出=&gt; 1 2 1.1.2 generator的”*”和”yeild” generator 必须要有* 配合yeild ,碰到yield 就停止，再次调用next就继续走当遇到return时就迭代完成了第一个next传递参数是没有效果的第二次next传递的参数 是第一次yield的返回值 原理图解: 1234567891011121314151617function * thing() &#123; let a = yield 1; return a; console.log(a); let b = yield 2; console.log(b); &#125;let it = thing();// console.log(it.next());console.log(it.next('2000'));console.log(it.next('4000'));console.log(it.next('end000'));/*输出=&gt;&#123; value: 1, done: false &#125;&#123; value: '4000', done: true &#125;&#123; value: undefined, done: true &#125;*/ 1.1.3 generator应用案例之promisify1234cat 1.txt2.txtcat 2.txt我很帅 实现123456789101112131415let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);function* readMethod() &#123; let data1 = yield read('./1.txt','utf8'); let data2 = yield read(data1,'utf8'); return data2;&#125;let it = readMethod();it.next().value.then(data =&gt; &#123; it.next(data).value.then(data =&gt; &#123; let &#123; done, value &#125; = it.next(data); console.log(done,value); //输出=&gt; true '我很帅' &#125;)&#125;) 1.1.3 async+await等价的“generator+co库”的实现async+await &lt;==&gt; generator+co库 改进以及开源co库的实现1234567891011121314151617181920212223242526272829303132333435363738let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);function* readMethod() &#123; let data1 = yield read('./1.txt','utf8'); let data2 = yield read(data1,'utf8'); return data2;&#125;/*let it = readMethod();it.next().value.then(data =&gt; &#123; it.next(data).value.then(data =&gt; &#123; let &#123; done, value &#125; = it.next(data); console.log(done,value); &#125;)&#125;)*/function co(it) &#123; //开源co库的实现 return new Promise((resolve, reject)=&gt;&#123; // 异步调用的问题 function next(data)&#123; let &#123; value, done &#125; = it.next(data); if(!done)&#123; value.then(data =&gt; &#123; next(data) &#125;, reject) &#125;else&#123; resolve(value); &#125; &#125; next(); &#125;)&#125;// let co = require('co'); //generator async =&gt; async flow generator coro coroutine//git地址:https://github.com/tj/co tj为express作者// 获取1.txt内容 2.txt 2.txt放的内容是最终的结果co(readMethod()).then(data=&gt;&#123; console.log(data); //输出=&gt; 我很帅&#125;) 1.1.4 async+await使用123456789101112//这就是一个语法糖let blueBird =require('bluebird');let fs = require('fs');let read = blueBird.promisify(fs.readFile);async function readMethod() &#123; let data1 = await read('./1.txt','utf8'); let data2 = await read(data1,'utf8'); return data2;&#125;readMethod().then(data=&gt;&#123; console.log(data); //输出=&gt; 我很帅&#125;) 通过babeljs.io转译后async和await的源码实现,function _asyncToGenerator(fn)函数部分(同function co(it))http://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=IYZwngdgxgBAZgV2gFwJYHsIwE4FNgAmAsrsgBboEAUAlDAN4BQMMANqTAcMsAIwwBeGMADuwVMhz5qAcgB0Ael5zkAD2QyANDITI4ADhk0A3MzYcuPAEyDhYiVMJVLfbboNHTLPMgTYsLlamAL5AA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion= 1.2 实际应用 一共四种实现方式 1.2.1 callback方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; /* *表示匹配所有 */ margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; /* 中间差10px*/ left: 0; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div style="position: relative"&gt; &lt;!--这里表示是在同一个轴上--&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); let ball1 = document.getElementById('ball1'); let ball2 = document.getElementById('ball2'); console.log(typeof $); function move(el, target, cb) &#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer); return cb(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;/* move($('#ball1'), 500, function () &#123; move($('#ball2'), 500, function () &#123; alert('移动完成') &#125;) &#125;)*/ move(ball1, 300, function () &#123; move(ball2, 300, function () &#123; alert('移动完成') &#125;) &#125;) /*move($('#ball1'), 500, function () &#123; //第一种方式：回调 move($('#ball2'), 500, function () &#123; alert('移动完成') &#125;) &#125;)*/ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.2.2 Promise方式 Promise的链式写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;) &#125; move($('#ball1'), 500).then(data=&gt;&#123; return move($('#ball2'), 500) &#125;).then(data=&gt;&#123; /*链式写法,根据上边的返回值*/ alert('ok'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.3 generator+co库方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve(); &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); //3s超时 &#125;) &#125; function *m() &#123; yield move($('#ball1'),500); yield move($('#ball2'),500); &#125; function co(it) &#123; return new Promise((resolve,reject)=&gt;&#123; function next(data) &#123; let &#123;value ,done&#125; = it.next(data); console.log(done) if(!done)&#123; value.then(data=&gt;&#123; next(data); &#125;,reject); &#125; else &#123; resolve(data); &#125; &#125; next(); &#125;) &#125; co(m()).then(data=&gt;&#123; alert('成功'); &#125;,err=&gt;&#123; console.log(err); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.3 async+await方式 async和await可以支持 try catch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; div div &#123; width: 100px; height: 100px; border-radius: 50%; background: red &#125; #ball1 &#123; position: absolute; top: 0; left: 0; &#125; #ball2 &#123; position: absolute; top: 110px; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="position: relative"&gt; &lt;div id="ball1"&gt;&lt;/div&gt; &lt;div id="ball2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let $ = document.querySelector.bind(document); function move(el, target, cb) &#123; // throw new Error(); return new Promise((resolve,reject)=&gt;&#123; let index = 0; let timer; timer = setInterval(function () &#123; if (index &gt;= target) &#123; clearInterval(timer) return resolve();; &#125; else &#123; el.style.left = ++index + 'px'; &#125; &#125;, 3); &#125;) &#125; // async和await可以支持 try catch async function m() &#123; // try&#123; await move($('#ball1'), 500); await move($('#ball2'), 500); // &#125;catch(e)&#123; // console.log(e); // &#125; &#125; m().then(data=&gt;&#123; alert('成功'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 所有效果如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-1/2.高阶函数]]></title>
    <url>%2F2018%2F06%2F17%2F2-1%3A2.%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1开篇1.1.1 编辑器 vscode webstorm code runner (可以片段运行代码)1.1.2 es6 1.1.1.1 异步的发展流程1.1.1.1 异步和同步的区别 异步(setTimeout ajax 事件)和同步的区别:同步表示连续执行，异步表示非连续执行1.1.1.2 回调函数的两种表现形式 回调函数 函数(封装，私有化),即以下两种方式:(1)高阶函数,一个函数执行后返回一个函数(2)函数可以当作参数传递给另一个函数 2.1柯里化2.1.1 柯里化和偏函数的解释 即:函数返回函数 ==别的叫法==&gt; 柯里化 偏函数… 2.1.2 判断内容的类型// 判断内容的类型// Object.prototype.toString.call(‘aaa’) = ‘[object Null]’1234567// 判断类型 有四种 constructor typeof instanceof Object.prototype.toStringfunction isType(content,Type) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g,''); //String return Type === str;&#125;let result = isType('hello','String');console.log(result); //输出:true 优化,类回调函数1234567891011121314151617181920212223242526272829function isType(type) &#123; return function (content) &#123; let str = Object.prototype.toString.call(content).replace(/\[object\s|\]/g, &apos;&apos;); return type === str; &#125;&#125;let util = &#123;&#125;;let type = [&apos;String&apos;,&apos;Object&apos;,&apos;Null&apos;,&apos;Function&apos;];type.forEach((item)=&gt;&#123; util[&apos;is&apos;+item] = isType(item);&#125;);console.log(util);console.log(util.isString(&apos;hello&apos;));console.log(util.isObject(&apos;Object&apos;));console.log(util.isNull(&apos;Null&apos;));console.log(util.isFunction(&apos;Function&apos;));/*输出=&gt;&#123; isString: [Function], isObject: [Function], isNull: [Function], isFunction: [Function] &#125;truefalsefalsefalse*/ 3.1 回调函数底层原理 回调函数(不一定是异步的)12345678910111213141516171819202122232425262728293031323334353637// 预置参数 lodash afterfunction after(times,callback) &#123; console.log(&apos;111****:&apos;+times); return function () &#123; console.log(&apos;222+++:&apos;+times); if(--times === 0)&#123; console.log(&apos;333====:&apos;+times); callback() &#125; &#125;&#125;let eat = after(3,function () &#123; console.log(&apos;吃完了&apos;)&#125;);eat();eat();eat();/*输出=&gt;111****:3222+++:3222+++:2222+++:1333====:0吃完了*/after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();after(3,function () &#123;console.log(&apos;吃完了&apos;)&#125;)();/*输出=&gt;111****:3222+++:3111****:3222+++:3111****:3222+++:3*/ 3.1.1 回调函数的缺点 1) 异步方法如果出错了不能捕获try/catch错误2) 获取的结果不能通过return返回3) 回调函数可能会产生 (回调地狱)12345678910111213//cat 1.txt =&gt; 模板//cat 2.txt =&gt; 数据// 我们可以引用一个模块 操作文件let fs = require(&apos;fs&apos;);// 相当于两个异步请求 有关系 关系是第二个请求 是依赖于第一个的fs.readFile(&apos;./1.txt&apos;, &apos;utf8&apos;, function (err, a) &#123; // error-first fs.readFile(&apos;./2.txt&apos;, &apos;utf8&apos;, function (err, b) &#123; // error-first console.log(a, b) &#125;);&#125;);/*输出=&gt;模板 数据*/ 3.1.2 同时两个异步请求问题的规避 两个异步请求 同时拿到两个异步请求的结果1234567891011121314151617181920212223let fs = require('fs');function after(times,callback) &#123; let arr = []; return function (data) &#123; // args = [1,2,3] arr.push(data); if(--times === 0)&#123; callback(arr); &#125; &#125;&#125;let out = after(2,function (data) &#123; // [] console.log(data);&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; out(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; out(b);&#125;);/*输出=&gt;[ '模板', '数据' ]*/ 3.1.3 回调函数及发布订阅原理代码演示123456789101112131415161718192021222324252627282930313233343536373839let fs = require('fs');// 发布(这件事发生时 我要依次执行) 订阅(我预先想到的事)let events = &#123; cbs:[], results:[], on(cb)&#123; this.cbs.push(cb); &#125;, emit(data)&#123; this.results.push(data); // this.cbs.forEach(fn =&gt; fn(this.results)) this.cbs.forEach(function (fn) &#123; return fn(this.results); //这种方式是箭头函数的简写 // fn(this.results); &#125;.bind(this)); &#125;&#125;;events.on(function (data) &#123; // 订阅的过程 // if(data.length === 2)&#123; console.log(data); // &#125;&#125;);events.on(function (data) &#123; // 订阅的过程 console.log(data+' =&gt; 很棒');&#125;);fs.readFile('./1.txt', 'utf8', function (err, a) &#123; events.emit(a);&#125;);fs.readFile('./2.txt', 'utf8', function (err, b) &#123; events.emit(b);&#125;);/* 输出=&gt;[ '模板' ]模板 =&gt; 很棒[ '模板', '数据' ]模板,数据 =&gt; 很棒*/ —title: 2-3.promise基础应用 date: 2018-06-17 21:59:26[TOC] 1.1promise Promises/A+规范官网https://promisesaplus.com/ 1.1.1 promise特性一 promise会立即执行12345678910console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1);&#125;);console.log(3);/*输出=&gt;213*/ 1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-3.promise基础应用]]></title>
    <url>%2F2018%2F06%2F17%2F2-3.promise%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1实现promise Promises/A+规范官网https://promisesaplus.com/ 1.1.1 promise特性一 promise会立即执行12345678910console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1);&#125;);console.log(3);/*输出=&gt;213*/ 1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 1.1.4 手写promise实现之发布订阅模式 cat 1.同步promise.js1234567891011121314151617181920212223242526272829console.log("1");let Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; console.log("3"); setTimeout(()=&gt;&#123; // resolve('买'); reject('不买'); &#125;)&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);console.log("2");/*130000000000 //过1秒钟再执行下面的2err 不买err 不买*/ 实现cat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142class Promise &#123; constructor(executor) &#123; this.status = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); //调用成功的状态 &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); //调用失败的状态 &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; if( this.status === 'pending')&#123; //发布订阅模式 console.log("00000"); this.onResolvedCallbacks.push(()=&gt;&#123; onFufilled(this.value); //一旦成功进入这个状态 &#125;); this.onRejectedCallbacks.push(()=&gt;&#123; onRejected(this.reason); //一旦失败进入这个状态 &#125;) &#125; &#125;&#125;module.exports = Promise; 1.2 原生promise1.2.1 promise解决回调地狱 准备1234#cat 1.txt2.txt#cat 2.txt数据 代码详解123456789101112131415161718192021222324252627282930313233343536// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); //如果promise内部有错误,它也会走失败. fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); //这里return加不加都行,一旦失败就不会成功了 resolve(data); &#125;); &#125;)&#125;// 成功的回调 或者失败的回调执行后可以返回一个promise// 会将这个promise的执行结果传递给下一次then中// 如果返回一个普通的值 ，会将这个普通值传递到下一次then的成功的参数read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); //输出=&gt;2.txt return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); //输出=&gt; 数据 return [data];&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; [ '数据' ],这里返回值为undefined,所以下一句输出undefined&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; undefined throw new Error('xxx');&#125;) // .then() .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功&#125;) .then(data=&gt;&#123; console.log('成功'); //输出=&gt; 成功&#125;).catch(err=&gt;&#123; //一旦出错用这个捕获,它会找最近的,剩下的处理不了的都可以用catch来捕获 console.log(err)&#125;) 输出=&gt;12345672.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:25:9)成功 .then() 什么都不传使用catch捕获12345678910111213141516171819202122232425262728293031323334// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); return [data];&#125;).then(data=&gt;&#123; console.log(data);&#125;).then(data=&gt;&#123; console.log(data); throw new Error('xxx');&#125;) .then() //什么都不传 // .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) // console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功// &#125;) .then(data=&gt;&#123; console.log('成功');&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 输出=&gt;1234562.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:23:9) 1.2.2 promise穿透 穿透的几种简写1234567891011121314151617let Promise = require('./Promise');let promise = new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;);// 成功不写的时候 默认就是value =&gt; value// 失败不写默认返回 err=&gt;&#123;throw err&#125;promise.then()//等同于// promise.then(function (data) &#123;return data&#125;)//等同于// promise.then(data =&gt; data).then(data=&gt;&#123; console.log(data);&#125;,err=&gt;&#123; console.log('err',err);&#125;)//输出=&gt; hello 1.2.3 promise A+测试规范npm install promises-aplus-tests -g 全局安装➜ promise-public-6-9 git:(master) ✗ promises-aplus-tests Promise.js #执行是否符合promiseA+检测12345678 The value is `1` with `Number.prototype` modified to have a `then` method ✓ already-fulfilled ✓ immediately-fulfilled ✓ eventually-fulfilled ✓ already-rejected ✓ immediately-rejected ✓ eventually-rejected872 passing (24s) 2.1 promise其他用法 自己实现的promisecat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165class Promise &#123; constructor(executor) &#123; this.status = &apos;pending&apos;; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;resolved&apos;; this.value = value; this.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;rejected&apos;; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 如果出现异常就走错误处理 &#125; &#125; then(onFufilled, onRejected) &#123; // 默认成功和失败不传的情况 onFufilled = typeof onFufilled === &apos;function&apos; ? onFufilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let promise2; promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === &apos;resolved&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;rejected&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;pending&apos;) &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;) &#125; &#125;); return promise2; &#125; catch(fn)&#123; return this.then(null,fn); &#125;&#125;Promise.all = (promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index = 0; let processData = (key, y) =&gt; &#123; index++ result[key] = y; if (promises.length === index) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; processData(i, y); &#125;, reject); &#125; &#125;)&#125;Promise.race =(promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;Promise.resolve = function (data) &#123; return new Promise((resolve,reject)=&gt;&#123; resolve(data); &#125;)&#125;Promise.reject = function (data) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(data); &#125;)&#125;// 实现多套promise共用的情况function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError(&apos;循环引用&apos;)); &#125; // &#123;then:&#123;&#125;&#125; let called; if (x != null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;)) &#123; try &#123; let then = x.then; // 如果是对象 我就试着取一下then方法 if (typeof then === &apos;function&apos;) &#123; // 就是promise了 then.call(x, y =&gt; &#123; // 成功和失败只能调用一个 if (called) return; called = true; // resolve的结果依旧是promise 那就继续解析 resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; called = true; reject(r);// 失败了就失败了 &#125;) &#125; else &#123; resolve(x); // 直接成功即可 &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); // 取then出错了那就不要在继续执行了 &#125; &#125; else &#123; resolve(x); &#125;&#125;// 目前是通过他测试 他会测试一个对象// 语法糖Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise;// npm install promises-aplus-tests -g// promises-aplus-tests 2.1.1 defer源码实现及用法.js 引用123456789101112131415let fs = require('fs');// Q库let Promise = require('./Promise.js');function read(path, encoding) &#123; let dfd = Promise.defer(); fs.readFile(path, encoding, function (err, data) &#123; if (err) return dfd.reject(err); dfd.resolve(data); &#125;); return dfd.promise;&#125;read('1.txt','utf8').then(data =&gt; &#123; console.log(data);&#125;)//输出=&gt; 2.txt 2.1.2 catch源码实现及用法.js 引用1234567891011121314151617let Promise = require(&apos;./Promise&apos;)let promise = new Promise((resove,reject)=&gt;&#123; reject(&apos;错误&apos;);&#125;)// 当前catch里只接受错误promise.then(null).catch(err=&gt;&#123; console.log(&apos;2&apos;,err);&#125;);Promise.resolve(&apos;123&apos;).then(data=&gt;&#123; console.log(data);&#125;)// 实现promise finaly是如何实现的/* 输出=&gt;1232 错误*/ 2.1.3 All方法源码实现及用法.js 引用面试:如何实现all和race源码all:所有方法都成功才成功,否则失败。race为一个成功就成功,一个失败就失败。这里new promise用的是原生的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;function all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index =0; let processData = (key, y) =&gt; &#123; index++ //每处理一次+1 result[key] = y; if (promises.length === index)&#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; //使用then调用promise的all里面的方法 processData(i, y); //i为位置,y为函数的返回值 &#125;, reject); //失败直接reject &#125; &#125;)&#125;//race为一个成功就成功,一个失败就失败function race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;all([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; [ '2.txt', '数据' ]race([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; 2.txt/*cat 1.txt2.txtcat 2.txt数据*/ 2.1.4 promisify及promisifyAll使每个方法都会多一个promise的方法 实现,参考bluebird这个库123456789101112131415161718192021222324252627282930// npm install bluebird// let bluebird = require('bluebird');let fs = require('fs');function promisifyAll(obj) &#123; // console.log(Object.keys(obj)); //可以拿到obj下面的所有方法,所有方法变成数组 Object.keys(obj).forEach(item=&gt;&#123; if (typeof obj[item] === 'function')&#123; // 把每一个函数 都promise化一下 ，每个方法都会多一个promise的方法 obj[item + 'Async'] = promisify(obj[item]); &#125; &#125;);&#125;promisifyAll(fs);function promisify(readFile) &#123; return function (...args) &#123; return new Promise((resolve,reject)=&gt;&#123; readFile(...args,function (err,data) &#123; if(err) reject(err); resolve(data); &#125;) &#125;); &#125;&#125;let read = promisify(fs.readFile); // 就会返回一个promise方法// fs.readFileAsync('1.txt','utf8').then(data=&gt;&#123;read('1.txt','utf8').then(data=&gt;&#123; console.log(data);&#125;)//输出=&gt; 2.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-3.this a test]]></title>
    <url>%2F2018%2F06%2F17%2F20180623%2F</url>
    <content type="text"><![CDATA[1.1.2 promise特性二及几个状态 (1)promise 本意 承诺 三个状态 成功态 失败态 等待态(2)默认是等待态 等待态可以变成 成功态/失败态(3)成功就不能失败 也不能 从失败变成成功(4)在低版本浏览器 不支持的 es6-promise(5)executor是立即执行的(6)每个promise实例都有一个then方法,参数是成功和失败，成功会有成功的值 失败(7) 同一个promise可以多次then// Promise是一个类// new Promise时 会传递一个执行器123456789101112131415161718192021222324252627console.log(2);let promise = new Promise((resolve,reject)=&gt;&#123; console.log(1); // resolve('hello'); //成功和错误只能执行一个 setTimeout(()=&gt;&#123; reject('错误'); &#125;,3000);&#125;);promise.then((data)=&gt;&#123; //一个promise可以then多次 console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);promise.then((data)=&gt;&#123; console.log('data',data);&#125;,(err)=&gt;&#123; console.log('err',err);&#125;);console.log(3);/*213err 错误 //等3秒再执行err 错误*/ 1.1.3 手写promise实现 代码同上12345678910111213141516171819//cat 3.promise.js//1.实现基本的promiselet Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; resolve('买'); // reject('不买'); //成功和错误只能执行一个&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;); 实现原生Promise123456789101112131415161718192021222324252627282930313233343536class Promise &#123; constructor(executor) &#123; // 默认的状态 this.status = 'pending'; // 原因 this.value = undefined; this.reason = undefined; // 成功存放的数组 this.onResolvedCallbacks = []; // 失败存放的数组 this.onRejectedCallbacks = []; // 默认让执行器执行 let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; // 成功了,只能是成功状态,不会执行失败的状态 this.value = value; &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; // 失败了,只能是失败状态,不会执行成功的状态 this.reason = reason; &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; &#125;&#125;module.exports = Promise; 1.1.4 手写promise实现之发布订阅模式 cat 1.同步promise.js1234567891011121314151617181920212223242526272829console.log("1");let Promise = require('./Promise')let promise = new Promise((resolve, reject) =&gt; &#123; console.log("3"); setTimeout(()=&gt;&#123; // resolve('买'); reject('不买'); &#125;)&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);promise.then((data) =&gt; &#123; console.log('data', data);&#125;, (err) =&gt; &#123; console.log('err', err);&#125;);console.log("2");/*130000000000 //过1秒钟再执行下面的2err 不买err 不买*/ 实现cat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142class Promise &#123; constructor(executor) &#123; this.status = 'pending'; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if(this.status === 'pending')&#123; this.status = 'resolved'; this.value = value; this.onResolvedCallbacks.forEach(fn=&gt;fn()); //调用成功的状态 &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); //调用失败的状态 &#125; &#125; executor(resolve,reject); &#125; then(onFufilled,onRejected)&#123; if(this.status === 'resolved')&#123; onFufilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason); &#125; if( this.status === 'pending')&#123; //发布订阅模式 console.log("00000"); this.onResolvedCallbacks.push(()=&gt;&#123; onFufilled(this.value); //一旦成功进入这个状态 &#125;); this.onRejectedCallbacks.push(()=&gt;&#123; onRejected(this.reason); //一旦失败进入这个状态 &#125;) &#125; &#125;&#125;module.exports = Promise; 1.2 原生promise1.2.1 promise解决回调地狱 准备1234#cat 1.txt2.txt#cat 2.txt数据 代码详解123456789101112131415161718192021222324252627282930313233343536// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); //如果promise内部有错误,它也会走失败. fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); //这里return加不加都行,一旦失败就不会成功了 resolve(data); &#125;); &#125;)&#125;// 成功的回调 或者失败的回调执行后可以返回一个promise// 会将这个promise的执行结果传递给下一次then中// 如果返回一个普通的值 ，会将这个普通值传递到下一次then的成功的参数read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); //输出=&gt;2.txt return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); //输出=&gt; 数据 return [data];&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; [ '数据' ],这里返回值为undefined,所以下一句输出undefined&#125;).then(data=&gt;&#123; console.log(data); //输出=&gt; undefined throw new Error('xxx');&#125;) // .then() .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功&#125;) .then(data=&gt;&#123; console.log('成功'); //输出=&gt; 成功&#125;).catch(err=&gt;&#123; //一旦出错用这个捕获,它会找最近的,剩下的处理不了的都可以用catch来捕获 console.log(err)&#125;) 输出=&gt;12345672.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:25:9)成功 .then() 什么都不传使用catch捕获12345678910111213141516171819202122232425262728293031323334// 1) 解决回调地狱let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; // throw new Error('xxx'); fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;read('./1.txt', 'utf8').then(data =&gt; &#123; console.log(data); return read(data, 'utf8')&#125;).then(data =&gt; &#123; console.log(data); return [data];&#125;).then(data=&gt;&#123; console.log(data);&#125;).then(data=&gt;&#123; console.log(data); throw new Error('xxx');&#125;) .then() //什么都不传 // .then(null,err=&gt;&#123; //直接进入失败分支,不会走前面的null分支(什么都不执行) // console.log(err); //打印错误行数,没有返回值即返回是undefined,undefined也是普通值,所以它认为也是成功// &#125;) .then(data=&gt;&#123; console.log('成功');&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 输出=&gt;1234562.txt数据[ '数据' ]undefinedError: xxx at read.then.then.then.then.data (/Users/00arunalldata00/007_studycoding/008_everest/20180609/003/promise-public-6-9/1.case.js:23:9) 1.2.2 promise穿透 穿透的几种简写1234567891011121314151617let Promise = require('./Promise');let promise = new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;);// 成功不写的时候 默认就是value =&gt; value// 失败不写默认返回 err=&gt;&#123;throw err&#125;promise.then()//等同于// promise.then(function (data) &#123;return data&#125;)//等同于// promise.then(data =&gt; data).then(data=&gt;&#123; console.log(data);&#125;,err=&gt;&#123; console.log('err',err);&#125;)//输出=&gt; hello 1.2.3 promise A+测试规范npm install promises-aplus-tests -g 全局安装➜ promise-public-6-9 git:(master) ✗ promises-aplus-tests Promise.js #执行是否符合promiseA+检测12345678 The value is `1` with `Number.prototype` modified to have a `then` method ✓ already-fulfilled ✓ immediately-fulfilled ✓ eventually-fulfilled ✓ already-rejected ✓ immediately-rejected ✓ eventually-rejected872 passing (24s) 2.1 promise其他用法 自己实现的promisecat Promise.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165class Promise &#123; constructor(executor) &#123; this.status = &apos;pending&apos;; this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; let resolve = (value) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;resolved&apos;; this.value = value; this.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === &apos;pending&apos;) &#123; this.status = &apos;rejected&apos;; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 如果出现异常就走错误处理 &#125; &#125; then(onFufilled, onRejected) &#123; // 默认成功和失败不传的情况 onFufilled = typeof onFufilled === &apos;function&apos; ? onFufilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let promise2; promise2 = new Promise((resolve, reject) =&gt; &#123; if (this.status === &apos;resolved&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;rejected&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; if (this.status === &apos;pending&apos;) &#123; this.onResolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFufilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;) &#125; &#125;); return promise2; &#125; catch(fn)&#123; return this.then(null,fn); &#125;&#125;Promise.all = (promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index = 0; let processData = (key, y) =&gt; &#123; index++ result[key] = y; if (promises.length === index) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; processData(i, y); &#125;, reject); &#125; &#125;)&#125;Promise.race =(promises) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;Promise.resolve = function (data) &#123; return new Promise((resolve,reject)=&gt;&#123; resolve(data); &#125;)&#125;Promise.reject = function (data) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(data); &#125;)&#125;// 实现多套promise共用的情况function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError(&apos;循环引用&apos;)); &#125; // &#123;then:&#123;&#125;&#125; let called; if (x != null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;)) &#123; try &#123; let then = x.then; // 如果是对象 我就试着取一下then方法 if (typeof then === &apos;function&apos;) &#123; // 就是promise了 then.call(x, y =&gt; &#123; // 成功和失败只能调用一个 if (called) return; called = true; // resolve的结果依旧是promise 那就继续解析 resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; if (called) return; called = true; reject(r);// 失败了就失败了 &#125;) &#125; else &#123; resolve(x); // 直接成功即可 &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); // 取then出错了那就不要在继续执行了 &#125; &#125; else &#123; resolve(x); &#125;&#125;// 目前是通过他测试 他会测试一个对象// 语法糖Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve,reject)=&gt;&#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise;// npm install promises-aplus-tests -g// promises-aplus-tests 2.1.1 defer源码实现及用法.js 引用123456789101112131415let fs = require('fs');// Q库let Promise = require('./Promise.js');function read(path, encoding) &#123; let dfd = Promise.defer(); fs.readFile(path, encoding, function (err, data) &#123; if (err) return dfd.reject(err); dfd.resolve(data); &#125;); return dfd.promise;&#125;read('1.txt','utf8').then(data =&gt; &#123; console.log(data);&#125;)//输出=&gt; 2.txt 2.1.2 catch源码实现及用法.js 引用1234567891011121314151617let Promise = require(&apos;./Promise&apos;)let promise = new Promise((resove,reject)=&gt;&#123; reject(&apos;错误&apos;);&#125;)// 当前catch里只接受错误promise.then(null).catch(err=&gt;&#123; console.log(&apos;2&apos;,err);&#125;);Promise.resolve(&apos;123&apos;).then(data=&gt;&#123; console.log(data);&#125;)// 实现promise finaly是如何实现的/* 输出=&gt;1232 错误*/ 2.1.3 All方法源码实现及用法.js 引用面试:如何实现all和race源码all:所有方法都成功才成功,否则失败。race为一个成功就成功,一个失败就失败。这里new promise用的是原生的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let fs = require('fs');function read(path, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, encoding, function (err, data) &#123; if (err) return reject(err); resolve(data); &#125;); &#125;)&#125;function all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; let index =0; let processData = (key, y) =&gt; &#123; index++ //每处理一次+1 result[key] = y; if (promises.length === index)&#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(y =&gt; &#123; //使用then调用promise的all里面的方法 processData(i, y); //i为位置,y为函数的返回值 &#125;, reject); //失败直接reject &#125; &#125;)&#125;//race为一个成功就成功,一个失败就失败function race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;)&#125;all([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; [ '2.txt', '数据' ]race([read('1.txt', 'utf8'), read('2.txt', 'utf8')]).then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(err);&#125;)//输出=&gt; 2.txt/*cat 1.txt2.txtcat 2.txt数据*/ 2.1.4 promisify及promisifyAll使每个方法都会多一个promise的方法 实现,参考bluebird这个库123456789101112131415161718192021222324252627282930// npm install bluebird// let bluebird = require('bluebird');let fs = require('fs');function promisifyAll(obj) &#123; // console.log(Object.keys(obj)); //可以拿到obj下面的所有方法,所有方法变成数组 Object.keys(obj).forEach(item=&gt;&#123; if (typeof obj[item] === 'function')&#123; // 把每一个函数 都promise化一下 ，每个方法都会多一个promise的方法 obj[item + 'Async'] = promisify(obj[item]); &#125; &#125;);&#125;promisifyAll(fs);function promisify(readFile) &#123; return function (...args) &#123; return new Promise((resolve,reject)=&gt;&#123; readFile(...args,function (err,data) &#123; if(err) reject(err); resolve(data); &#125;) &#125;); &#125;&#125;let read = promisify(fs.readFile); // 就会返回一个promise方法// fs.readFileAsync('1.txt','utf8').then(data=&gt;&#123;read('1.txt','utf8').then(data=&gt;&#123; console.log(data);&#125;)//输出=&gt; 2.txt]]></content>
  </entry>
</search>
