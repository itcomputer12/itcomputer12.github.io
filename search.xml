<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js]]></title>
    <url>%2F2018%2F06%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[[TOC] #1 继承 ##1.1 如何实现一个类？ 类的继承 三种属性 公有属性(proto) 私有属性 静态方法(静态属性) ###1.1.1公有属性(proto)及私有属性12345678910111213141516171819202122232425function Parent()&#123; // 构造函数中的this 通过new调用的那么this指代的是实例 this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;// 1)console.log(Parent.prototype.constructor ===Parent); //输出:true// 2)let parent = new Parent();parent.__proto__.eat(); //输出:eat 会先去找私有属性找不到再去找公有属性function Child() &#123; this.age = 9; Parent.call(this); //等价于 this.name = 'parent';&#125;let child = new Child();console.log(child.__proto__.constructor == Child); //输出:trueconsole.log(typeof child.constructor); //输出:functionconsole.log(Child.age); //拿属性应该通过实例child.ageconsole.log(child.age); //输出:9// 一.继承私有属性 Parent.call(this);console.log(child.name); //输出:parent 图解 ###1.1.2 类的继承 ###1.1.2.1 继承的错误的用法123456789101112131415161718192021222324function Parent()&#123; this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;function Child() &#123; this.age = 9; Parent.call(this);&#125;//错误写法Child.prototype = Parent.prototype; //指向同一个,儿子改父亲也会改,比较危险,不推荐这么搞。不是父子成兄弟了,共享一个媳妇,乱套了// 继承公有属性和私有属性// Child.prototype = new Parent(); // 不会使用这种方式Child.prototype.smoking = function ()&#123; console.log('吸烟');&#125;let child = new Child();child.eat(); //输出:eatChild.prototype.a = 100;let parent = new Parent();console.log(parent.a); //输出:100 图解 ###1.1.2.2 继承的正确的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Parent()&#123; this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;function Child() &#123; this.age = 9; Parent.call(this);&#125;Child.prototype.smoking = function ()&#123; console.log('吸烟');&#125;//1）正确写法:// Child.prototype.__proto__ = Parent.prototype; //老的写法// Object.setPrototypeOf(Child.prototype, Parent.prototype); //ES6写法。等同于上一句的写法,这个种使用方式更正规,效果一样//2）只继承公有属性://实现Object.create()function create(parentPrototype)&#123; function Fn()&#123;&#125; //Fn()是实例,得等它去原型上找 Fn.prototype = parentPrototype; return new Fn();&#125;Child.prototype = create(Parent.prototype);// Child.prototype = Object.create(Parent.prototype);let child = new Child();child.eat(); // 输出:eatconsole.log(child.constructor); // 输出:[Function: Parent]//3）继承Child://实现Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);function create(parentPrototype,props)&#123; function Fn() &#123;&#125; Fn.prototype = parentPrototype; let fn = new Fn(); for(let key in props)&#123; Object.defineProperty(fn, key, &#123; ...props[key], enumerable:true &#125;); &#125; return fn;&#125;/*Child.prototype = Object.create(Parent.prototype,&#123;constructor:&#123;value:Child&#125;&#125;);let child = new Child();console.log(child.constructor); //输出:[Function: Child]*/ (1)相当于建了一个空的构造函数,指向父类的原型,相当于一个中转。(2)改变实例,父亲的原型不变。这里parentPrototype最终指向Parent类,也就是child.constructor指向Parent类。 ##1.2 ###1.2.1 Object.defineProperty()方法详解1234567891011121314151617let a = &#123;&#125;// a.name = 1;// ES5Object.defineProperty(a, 'name', &#123; enumerable: true, // 表示这个属性是否可以被枚举出来 configurable: true, // 表示这个属性是否可被删除 // writable:true, //是否这个属性能够被改 get() &#123; // value可以替换成set和get console.log('get'); return 1; &#125;, set(val) &#123; console.log('设置值') &#125;&#125;);console.log(a.name); //输出: get 1a.name = 200;//输出: 设置值]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js初识和特性]]></title>
    <url>%2F2018%2F06%2F16%2Fnode.js%E5%88%9D%E8%AF%86%E5%92%8C%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[[TOC] 1.1初识node.js(1)1.流行的语言排行站点123https://code.google.com/https://archive.codeplex.com/https://www.codeproject.com/ 2.nodejs官网1http://www.dcloud.io/ #hbuilder代码提示功能 3.Javascript是其编程语言123虚拟机性能：Google V8本身使用了一些最新的编译技术，使得Js运行效率相当高；开发成本：Javascript活跃于浏览器上，使用人数多，入门成本较低；没有历史包袱：Javascript单线程，没有服务端的IO处理，没有各种历史存在的库。 ##1_1 js循环1_1.1 代码循环示例1234console.log('111');for(var i=0;i&lt;10;i++)&#123; console.log(i)&#125; node启动httpserver2_1.1 node启动httpserver123456var http=require("http");http.createServer(function (req,res) &#123; res.write("webcome to arun\'s world!"); res.end(); console.log("aaaa");&#125;).listen(8999); ##2_1 Js同步异步2_1.1 输出文件夹下文件123456789//这是一个异步的过程:输出文件夹下的文件var fs=require('fs');fs.readdir(".", function (err, filenames) &#123; var i; for (i = 0; i &lt; filenames.length; i++) &#123; console.log(filenames[i]); &#125;&#125;);console.log('End.'); 2_1.2 js程序模块化和程序可读性12345678910111213141516171819202122232425262728//###二、js程序模块化和程序可读性var Person = function(name) &#123; var p = &#123; name: name, age: 0 &#125;; var pub = &#123; setName: function (name) &#123; p.name = name; &#125;, getName: function () &#123; return p.name; &#125; &#125;; return pub;&#125;;var p1=new Person('name1');console.log(p1.getName());console.log(p1.age)p1.setName("name2");console.log(p1.getName());/*name1undefinedname2*/ 2_1.3 js封装继承多态经典案例12345678910111213141516171819202122function parent()&#123; this.name='Name'; this.say=function()&#123; console.log('I can say.'); &#125;&#125;function child()&#123; var p=new parent(); p.name1='Name1'; p.say=function()&#123; console.log('Child say.'); &#125;; return p;&#125;var p=new parent();console.log(p.name); //Namep.say(); //I can say.var c=new child();console.log(c.name); //Name 继承console.log(c.name1); //Name1c.say(); //Child say. 重载 2_1.4 js同步异步区别 代码演示123456789101112131415161718192021222324252627282930313233343536var http=require("http");var exec=require('child_process').exec;//示例化一个服务器var server=http.createServer(onRequest);//设置监听端口server.listen(8080);console.log("Server is starting...");//定义请求触发时的执行代码function onRequest(request,response) &#123; console.log("Accept a request!"); // sync(); async(response); // response.write("You send a request!"); // response.end();&#125;//同步方法function sync() &#123; var time=new Date().getTime(); while (new Date().getTime() &lt; time+10000);&#125;//异步调用function async(res) &#123; exec('find /',&#123;time:1000,maxBuffer:2048&#125;, function (err,stdout,stderr) &#123; console.log("start exec"); res.writeHead(200,&#123;'Content-Type':"text/plain",'charset':'utf-8'&#125;); // res.write('正在执行异步方法.'); res.write(stdout); res.write('Find complete'); res.end(); &#125;);&#125; 同步调用过程,如图可以看到阻塞了,请求非常的慢]]></content>
  </entry>
</search>
